![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAAC7CAIAAACvjEamAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAZdSURBVHhe7dq9qiRFGIfxCRQjDQQRE0EzRTZU140NxWtQNDP0BsRsFQwE8QY0XVwQA29DEFm8gXMFIrsei+1hevrr7beq3n/31Ozz8gvPfHU/U9Wnzzk8vLkLhCMsSBAWJAgLEoQFCcKCBGFBgrAgQViQICxIEBYkCAsShAUJwoIEYUGCsCBBWJAgLEgQFiQICxKEBQnCggRhQYKwIEFYkCAsSBAWJAgLEoQFCcKCBGFBgrAgQViQICxIEBYkCAsShAUJwoIEYUGCsCBBWJAgLEgQFiQICxKEBQnCggRhQYKwIEFYkCAsSBAWJAgLEoQFCcKCBGFBgrAgQViQICxIEBYkCAsShAUJwoKENqx/H33/weGFw9N56XDvx7+ejH7g3D+/ftH95HRWH4tLIwnr8e1vn6YYhvPq4bPfb/8b/WTnweevH3/IMV/+8nj08EYtfZGMAzXr/Ns7mqxjNXvWuik45sFhPbl9dP/eK8e3M5w33/3278nxMj6MPVeQF2F5GZ8wzcff/Dn6+eKqupkttSGE5fLHdx8e38XCTN/c6kNWJ/ccXBTCWreayPTqu3K5Ok27bRHWCs/CMz1YS4e1YBrdEwnL4uzjzicPRw+s3wfPZ/r8l4+wFjm3s9m3Zd9iGB1cT74FH35fhLVo9f6T8YaMxy4tP/Yi19yGSFjz7FXEPjrG7S77Jrv9otM7GpeMsGYYZaRZPTTGw1cfa7SVe0r2RVgzjLPr+bte7g36EWMbLTgEeyGsGcap9exHRlie3++MQ9DQlRZhjRmfxHlejbCc10lLZTf0fxCENWb8dubMoj4s42i2cglPWGNLq4X/iNSHdQW7IWENGC/vv/1dH1ZS3/e+CGsgZA8KCWtpR27lMouwBpYORxr/y4eEFfJOdkRYAyHrhDos/5PsiLAGlsLKOhwhYRkHtIl/diCsgZBL5ksO68FPbx2fZWGeO7z89c17o0cVIKwBwiIsj7Cwsu4eEVZCWAOsWITl0XBYSycmDWF101JYV3+7Yfewcm/wRoUV9TydsLDS+F8+JKyQdzJFWNPZIqyQdSIkrKVNufJPOpuFtXQiLy2ssuOZHZbxMfxXNvVhGRcEudcoI4Q1mo3CCjmj9WGF9D1r97DS7LKFRW3NneywjCbSOD9JfViiC6wtGV9R//VAEhVWyB/rTrLDSoyTus2/Juv2wS21ElbZP06WhGV8kjSeD1MZllF25T64JeMgZJ3LkLCi3sxJSVjGm0jjeR81YRlf9DSt7IOdkLvNIWEZR7Xsu1oSVmKsGWlW46gJq34jvhzGZ/E3ERJW+N3mwrDsZWP194jisIzPn6at5SoxPo5/nQgJK/ymYGFYib1o2Yt5WVj2tV1zy1VifD/9Z7Q+LOMZin8ZKg/LvtJKY7yngrAq18iLtbRUpHF+VSrDss9j8S9D5WEl9saUZul854Zlr1Vpyq4DLkH9MlwTll1Vzde1KqzE3hC7mZ71rLBWX6KhWwyzjEUrzWpbxWHZVaWpubqoDWv1zZ3mvBhnWKsLVZoWL61G7F2+GyORsrCKdxun2rASz3E5Tfd2V8PyLIRpGrrPbls9zd3MhpIblvO1pltHloCwkqy2ouZqquo4v0vdnO/+zrDsDXc09VcXMWEl/j0xZK6sqk5WW7oJuWYNCyvZrK0ruK5asntblTvgSWRYHfWhifrkF8t5DRQ+sfcC48NKRJdcV7xQTWVdEtVP+C0bSVidwKXrKq+oVm1zaSH6ugrD6lQu7K3f/AzhuZ+XO7Eb35Q8rJOswq7+QqpG8S655bXEdmGdc955h0fZnXc1wmoeYfW2Cevtw/PHJ12Yj35+Z/SQGj989cbxeRfmxfdfGz0kBGH1CCsQYfUIKxBh9QgrEGH1CCsQYfUIKxBh9QgrEGH1CCsQYfUIKxBh9QgrEGH1tgnrGUFYPcIKRFg9wgpEWD3CCkRYPcIKRFg9wgpEWHiGEBYkCAsShAUJwoIEYUGCsCBBWJAgLEgQFiQICxKEBQnCggRhQYKwIEFYkCAsSBAWJAgLEoQFCcKCBGFBgrAgQViQICxIEBYkCAsShAUJwoIEYUGCsCBBWJAgLEgQFiQICxKEBQnCggRhQYKwIEFYkCAsSBAWJAgLEoQFCcKCBGFBgrAgQViQICxIEBYkCAsShAUJwoIEYUGCsCBwc/d/w8YtMQ7Uv0UAAAAASUVORK5CYII=) TM

The SubThought Premise Language

version 3.0

by

Michael S P Miller

The SubThought Premise Language

The SubThought Premise Language

version 3.0

by

Michael S. P. Miller

Copyright © 2013 – 2025. Michael S. P. Miller.

All Rights Reserved. No part of this book may be reproduced in any form by any electronic or mechanical means (including photocopying, recording, or information storage and retrieval systems) without permission in writing from the author–except in the case of a reviewer who may quote brief passages embodied in critical articles or in a review.

Trademarked names may appear throughout this book. Rather than use a trademark symbol with every occurrence of a trademarked name, names are used in an editorial fashion, with no intention of infringement of the respective owner’s trademark or copyright. The same applies to quotations or synopses of copyrighted material.

The information in this book is distributed on an “as is” basis, without warranty. Although every precaution has been taken in the preparation of this work, neither the author nor the publisher shall have any liability to any person or entity with respect to any loss or damage caused directly or indirectly by the information contained in this book. The source code examples and specifications in this book are for illustrative purposes only, and are therefore provided as is, without warranty of any kind, neither expressed nor implied that the examples work or are fit for a particular purpose. The author and publisher assume no responsibility or liability for damages or losses, neither incidental nor consequential, incurred as a result of using the provided specifications or source code.

The Premise Language<sup>TM</sup>, The SubThought Premise Programming Language<sup>TM</sup> and The SubThought Premise Logo<sup>TM</sup>, the [P] logo<sup>TM</sup>, are Copyright © 2013 – 2022 SubThought Corporation. All Rights Reserved.

For comments on the Premise Language contact: [subthought@hotmail.com](mailto:subthought@hotmail.com)

For electronic inquiries or permissions contact: <SubThought@hotmail.com>.

by mail: SubThought Corporation, 254 N. Lake Ave. #213, Pasadena, CA 91101 USA

This book was published in the United States of America.

Paperback ISBN-13: 979-8-849321-64-6 Paperback ISBN-10: 8-849321-64-3  
Hardcover ISBN-13: 979-8-849796-21-5 Hardcover ISBN-10: 8-849796-21-8

Cover by Michael S. P. Miller

Document version: 7.00

For those who seek truth.

# Contents

[Figures 12](#Toc72520487)

[Tables 12](#Toc72520488)

[Acknowledgements 13](#Toc72520489)

[Disclaimer 13](#Toc72520490)

[Introduction 15](#Toc72520491)

[1\. Getting Started 19](#Toc72520492)

[2\. The Interpreter 21](#Toc72520493)

[3\. Taxonomy 25](#Toc72520494)

[4\. Control Flow 62](#Toc72520495)

[5\. Code Examples 74](#Toc72520496)

[6\. Foundation Modules 111](#Toc72520497)

[7\. Quick Reference 112](#Toc72520498)

[Bibliography 123](#Toc72520499)

[Index 125](#Toc72520500)

# Figures

[Figure 1. The Premise Interpreter Architecture 21](#Toc113140549)

[Figure 2. Data type taxonomy. 25](#Toc113140550)

# Tables

[Table 1. SubThought Premise Taxonomy 26](#Toc113140555)

[Table 2. SubThought Premise Taxonomy (cntd.) 27](#Toc113140556)

[Table 3. Function Quick Reference 121](#Toc113140557)

# Acknowledgements

“Do you see over yonder, friend Sancho, thirty or forty

hulking giants? I intend to do battle with them and slay them.”

― Miguel de Cervantes Saavedra, Don Quixote

This work was not possible without the efforts and advice of Dr. Sheldon Linker, whose collaboration on terminology and functionality was most welcome, and combined with his proficient coding skills led to the 2013 Java implementation of a just in time interpreter: The Premise 0.1 Executive.  
Suzuki Hisao's lucid and concise C# implementation of Nukata Lisp Lite was insightful, as was Peter Norvig's implementation of JScheme. Allen Holub's book Compiler Design in C was also instructive, particularly in the area regarding approaches to tokenization and parsing. Christian Queinnec's tome, Lisp In Small Pieces, also provided invaluable insights on expression evaluation. Christian's encouragement on this project was greatly appreciated. Roland Hausser's left associative grammar was pivotal in the tokenizer design.

The author would also like to thank Aaron Hosford for his suggestions on numeric similarity metrics, Ryan Hewitt for his comments on prototype construction, Brian Will for his ideas on restricted scoping, Dr. Ghassan Azar, Todd Kaufmann, Dr. Michael Schuresko, Robert Rossi, Jean-Louis Villecroze and the rest of the Premise Language group for their constructive feedback and suggestions.

# Disclaimer

The source code examples and specifications in this book are for illustrative purposes only, and are therefore provided as is, without warranty of any kind, neither expressed nor implied that the examples work or are fit for a particular purpose. The author and publisher assume no responsibility or liability for damages or losses, neither incidental nor consequential, incurred as a result of using the provided specifications or source code, up to and including loss of business, injury, or death.

# Introduction

The Premise Language is a functional prototype programming language which combines high level intrinsic primitives with seamless object persistence. The goal of the Premise Language is to provide a platform for artificial intelligence programming. Software agents written in SubThought Premise share a knowledge base where they can create, modify, and delete object instances amongst themselves in a stigmergic manner. SubThought Premise is influenced by Lisp, Self, JavaScript, OPS5, and CLIPS.

The Premise Language was developed by Michael S. P. Miller and Sheldon O. Linker during 2013 and 2014. In creating a platform for agent based programming for intelligent systems ( PAM-P2, JCB English ) they found a need for a very high level language in which to code asynchronous agent processes to perform complex pattern matching and inference. They explored the Sapir-Whorf hypothesis as it relates to computer programming–namely, that the primitive operations available in a computer language influence the way software developers frame and solve problems, and it was early determined that the primitives of the needed language should be very high level and include logical and similarity-based pattern matching, inference, messaging, stigmergy, and asynchrony. The language combines elements of declarative, functional, and imperative programming with seamless persistent object storage and retrieval. The goals of The Premise Language are simple:

- To define memory as a portable abstraction across different physical implementations. SubThought Premise uses a persistent object store as its memory.
- To facilitate the fast formation of relationships in a persistent memory. Constructing persisted records in SubThought Premise is the same as asserting facts to the working memory of other declarative language platforms such as CLIPS or OPS.
- To allow rapid interrogation of relationships in the memory.
- To provide scalability to billions of persisted records.
- To explore the Sapir Whorf hypothesis as it relates to computer programming: that the constructs available in computer languages influence the way people think about and solve problems.
- To explore the stigmergic programming paradigm, where objects constructed by one agent are later used or consumed by other agents.
- To provide a clear and concise API.

The Premise Language serves as a testbed for agent programming. Functions are the primary unit of processing. Numbers, strings, literals, prototypes, persisted records, lexicons, lists and calls provide the primary data types. The Premise Language opens up new possibilities for knowledge representation and artificial intelligence programming.

I hope you enjoy using this language.

Michael Miller

February 2019

## Document Conventions

The following are conventions used in this document.

### Source Code

SubThought Premise source code will appear in Courier New font in a colored text region. The gray text region depicts a session in the Premise Interpreter.
```clojure
> (take "{a b c}")

.: {{a b c}}
```

A green text region depicts SubThought Premise source code snippets that appear in a file editor.

```clojure
(relation Problem

:Name :Status

)
```
A blue text region depicts non-SubThought Premise source code snippets that appear in a file editor.

```SQL
SELECT DISTINCT LENGTH(CategoryName)

FROM Category
```

### Source Code Comments

In-line comments are denoted by semicolons. Everything from the comment to the end of the line is ignored by the interpreter.

`; this is an in-line comment`

Multi-line comments are delimited by double quotation marks. Everything between the delimiters is treated as a single string and returned as-is by the interpreter. A free standing string, not part of a function or macro call, evaluates to itself, and thus can be used as a comment.
```lisp
"this is a

multi-line

comment"
```
## Language Style Conventions

As a matter of style, each of the following language elements is written in a specific case:

Modules    are written in Pascal case.

Types  are written in  Pascal case.  
:Slots           are written in Pascal case with a preceding colon.

!methods    are written in camel case with a preceding exclamation point.  
functions   use camel case for verbs and Pascal case for nouns.  
?locals (local variables) are in camel case with a preceding question mark.

?Modular (modular variables) are in Pascal case with a preceding question mark.

?Globals (global variables) are in Pascal case with a preceding question mark.

?CONSTANTS are written in upper case with a preceding question mark.  

# 1\. Getting Started

To use the Premise Language, download the SubThought Premise executable to a folder on your computer then extract the file using standard decompression software.

To run the SubThought Premise evaluator type the following:

`premise`

Example:
```bash
C:\\projects\subThought Premise\>SubThought Premise

[SubThought Premise :Version 0.2.0 20210501.001 :OS Windows 10.0.17134 :Edition Community]

Enter your code followed by a blank line. Type (help), (copyright) or (license) for

information. Type (grok (file path "file.th")) to read a file. Type (bye) to exit.

> (copyright)

Copyright (c) 2014-2021 SubThought Corporation, All Rights Reserved.

.: nil

>
```

# 2\. The Interpreter

The goal of SubThought Premise is to facilitate fast persistent relationship formation in a client server environment. Clients connect to the server and execute expressions. The expressions create and modify records in the object store.

![Diagram

Description automatically generated]

Figure 1. The Premise Interpreter Architecture

The Premise Language interpreter follows several guiding principles, among them:

1. Metacircular evaluation. Parts of Premise are written in the Premise Language itself.  

2. A Lisp-1 approach to symbol and function lookup is employed. This means that symbols and functions can share the same symbol environment. Because symbols are prefixed by question marks and functions are not, the difference between the variable "?foo" and the function "foo" is evident. This eliminates one source of complexity for Lisp like languages.
3. The main point of The Premise Language is to build shared structures. To that end, relations, premises, and certain containers are persisted in an object store (e.g., a RAM database) to facilitate pattern matching over persisted records, and to facilitate concurrent access to shared structures.

## The Read Evaluate Print Loop

The Premise Language interpreter, otherwise known as the Read Evaluate Print Loop, allows users to enter expressions at the prompt (i.e., >). The interpreter evaluates the expression and returns the result. The result is printed after the ergo sign (i.e., .:). For example, when the literal true is entered at the prompt, it evaluates to itself and is returned by the interpreter as follows:
```clojure
 > true

.: true
```
An expression that adds two numbers together would return the sum like this:

```clojure 
> (+ 1 2)

.: 3
```

To print "Hello World" one would type the following.

```clojure
> (tell user "Hello, World. \\n")

Hello, World.

.: told
```
## Imperative Programming

The Premise Language facilitates imperative, functional, and declarative programming. For example, adding the numbers from one to ten in an imperative style could involve defining a variable total to store the result, and looping an iteration variable from 1 to 10.

```clojure 
> (let ?total 0) ; bind  ?total to 0

(step ?i from 1 to 10

(set ?total (+ ?total ?i))) ; set ?total to the result of adding ?total and ?i

?total) ; return ?total

.: 55
```

## Functional Programming

Adding numbers in a functional style might involve generating a list of numbers, walking through the list, and adding the numbers until we reach the end of the list. This approach eliminates the need for a total variable since the result is recursively kept on the program stack.

```clojure
> (function sum1 {list ?numbers}
    (if (void-p ?numbers)
      0 ; return zero
     else
      (+ (@ ?numbers) ; add the first number
         (sum (rest ?numbers)))) ; to the sum of the remaining numbers
  )

.: sum1

> (range 1 to 10) ; generate a list of numbers

.: {1 2 3 4 5 6 7 8 9 10}

> (sum1 (range 1 to 10)) ; test the function

.: 55
```
An even more concise approach to sum uses the function reduce.
```clojure
> (function sum2 {list ?numbers}
    (reduce ?numbers +)
  )

.: sum2

> (sum2 (range 1 to 10))

.: 55
```

## Declarative Programming

Declarative programming involves establishing a set facts and writing a query or rule to utilize the facts. In The Premise Language, this approach utilizes relation instances, called "thoughts."

```clojure
> (relation Addend ; make an Addend relation

:Value

:Counted false

)

.: Addend

> (step ?i from 1 to 10

(new Addend :Value ?i)) ; make the individual addends

.: Addend_10

> (relation Total ; make a total relation

:Result 0

)

.: Total

> (new Total) ; make a new total

.: Total1

> (with

[Total ^ as ?total] ; match the Total

[Addend ^ as ?addend :Value as ?value :Counted = false] ; match uncounted

do

(put ?addend :Counted true) ; indicate that the addend was used

(==> ?total + :Result ?value) ; apply + to :Result and ?value, put in :Result slot

(:Result ?total)) ; return the :Result slot value

.: 55
```

# 3\. Taxonomy

The following figure depicts the intrinsic data types of the Premise Language. The italicized types are abstract.

![Diagram

Description automatically generated]

Figure . Data type taxonomy.

'''
Premise Taxons 

├── variant  ; an abstract value of any type   
|├── nothing ; a concrete value representing nothing.  It is usually represented by a special taxon meaning Nothing. 
||├── nil ; a concrete unspecified value. 
|├── thing ; an abstract value representing something.  
||├── atom ; an abstract simple thing  
|||├── number; an abstract number 
||||├── big ; a concrete  integer longer than 128 bits 
||||├── complex ; a  concrete number with real and imaginary parts 
||||├── imaginary ; a concrete coefficient for the square root of -1  
||||├── integer ; a concrete 64 bit signed integer 
||||├── long ; a concrete 128 bit signed integer
||||├── rational ; a concrete number as numerator \/ denominator
||||├── real ; a concrete decimal number in scientific notation 
||||├──  float ; a concrete concrete 128 bit floating point number 
||||├──  unsigned ; concrete an unsigned 64 bit integer. 
|||├──  time ; an abstract measurement 
||||├──  instant ; an abstract single point in time. 
|||||├──  tick ; a concrete nanosecond 
|||||├──  moment ; a concrete nanoyear (0.0031573275 seconds) 
|||||├──  second ; a concrete second 
|||||├──  date ; a concrete Uconcrete TC date 
||||├──  interval ; a concrete period between two time instants 
|||├──  identifier ; al abstract non-delimited case insensitive string 
||||├──  symbol ; a concrete question prefixed mutable variable 
|||||├──  constant ;a concrete question prefixed immutable variable 
|||||├──  alias ; a concrete alias for a symbol. 
||||├──  literal ; a concrete  undelimited alphanumeric sequence 
|||||├──  function ; a concrete literal that defines a function 
||||||├──  anonym ; an concrete anonymous function 
||||||├──  esonym ; an concrete internally named function 
||||||├──  exonym ; a concrete user named function 
||||||├──  generator ; a concrete function that creates a series 
||||||├──  intrinsic ; a concrete language intrinsic function 
||||||├──  macro ; a uconcrete ser named macro 
||||||├──  method ; a concrete exclamation prefixed function literal
||||||├──  predicate ; a concrete function requiring a single argument and returning a truth value 
||||||├──  rule ; a concrete spontaneously executed rule 
||||||├──  thunk ; a concrete evaluation delay 
||||||├──  keyword ; a concrete reserved literal 
|||||||├──  choice ; a concrete value set for a symbol 
|||||||├──  option ; a concrete literal function parameter option 
|||||||├──  outcome ; a concrete function result 
|||||||├──  truth ; a concrete truth value 
|||||||├── sigil ; a concrete literal 
|||||├──  module ; a  concrete literal defining a module 
|||||├──  slot ; a  concrete colon prefixed property identifier 
|||||├──  resource ; an abstract resource 
||||||├──  assortment ; an abstract unordered grouping 
|||||||├──  collection ; a concrete assortment of keys 
|||||||├──  configuration ; a concrete  assortment of persisted key value pairs. 
|||||||├──  enumeration ; a concrete  assortment of name to number pairs 
|||||||├──  environment ; a concrete  assortment of symbol to value pairs 
|||||||├──  lexicon ; a concrete  assortment of key to value pairs 
||||||├──  relation ; a  concrete persisted relationship 
||||||├──  thought ; a  concrete  persisted relationship instance 
||||||├──  structure ; a concrete  ephemeral relationship 
||||||├──  ephemeron ; a  concrete  unpersisted structure instance 
||||||├──  continuation ; a  concrete  continuation resource 
||||||├──  data ; a  concrete data base connection  
||||||├──  file ; a  concrete  file resource 
||||||├──  index ; a concrete  relation access resource 
||||||├──  iterator ; a  concrete traversal resource 
||||||├──  knowledge ; a  concrete knowledge base connection
||||||├──  listener ; a  concrete task to listen concrete  on a port 
||||||├──  pipe ; an  concrete input output resource 
||||||├──  series ; a  concrete possibly infinite list. 
|||||||├──  cursor ; a  concrete handle to a list of premises 
||||||├──  task ; a  concrete task resource 
||||||├──  uid ; a  concrete unique identifier 
||├──  sequence ; an abstract ordered grouping 
|||├──  call ; a  concrete function call 
|||├──  expression ; a concrete  undelimited sequence of variants 
|||├──  list ; a  concrete curly brace delimeted sequence of variants
|||├──  string ; a concrete double quote a delimited character sequence 
|||├──  vector ; a concrete pipe delimited sequence of numbers or literals
|||├──  tuple ; a concrete square bracket delimited sequence of variants
||||├──  pattern ; a concrete square bracket delimited sequence containaing a literal and slot function value or slot function symbol or slot function call triples
||||├──  premise ; a tuple containing a literal and slot value pairs 
'''

Table 2. SubThought Premise Taxonomy (cntd.)

## Variants

In SubThought Premise, all values are typed. Variables (also called symbols) are bound to typed values, but the variables themselves are not typed. A variant is a value that can be any type. Variants are either nothing or something (i.e. a thing).

## Nothing

The type nothing represents values that do not exist. The value nil represents something that is unspecified. Typically when a value is not provided for a property of an object, the default value will be nil. The function is can be used to determine whether or not a value is unspecified.

## Things

The type thing represents a value that exists. The function thing-p can be used to detect a value that is not nil. The thing type is subdivided into atom and sequence.

## Atoms

An atom is a number, time value , or identifier.

### Numbers

The number data type encapsulates several sub types: integer, long, rational, real, imaginary, and complex.
'
#### Integers

Positive and negative decimal integers up to 64 bits are supported.

```
\-5 +3

+999999999999999999 -999999999999999999
```

##### Radix

Integers from radix 2 through radix 36 of the form \#tDDrSN… are supported, where t is a type (c-complex, y-imaginary,
 i-integer, n-long, b-big, a-rational, r-real, f-float, u-unsigned, x-infinity, y-ninfinity, z-undefined),
 D is a decimal number between zero and nine, S is an optional sign for positive (+) or negative (-) number, and N is a number from zero (0) to nine (9) or an uppercase letter from A through Z. The radix combination DD must be within the range of 2 to 36 inclusive and the digits N must be less than DD. For example #2r has digits 0 and 1 while #16r has digts 0 through F.

```  
#02r10110 #16r-778CF20 #36r+84QQN250MLQZ
```

##### Binary

Binary integers (#2r) are supported in the abbreviated form #bSN… for N equals 0 or 1.

```
#ib1010 #ib-10101 #ib0
```
##### Octal

Octal integers (#8r) are supported in the form #oSN… for N between 0 and 7.

```  
# o1234 #o0 #o+72342
```
##### Decimal

Decimal integers (#10r) are supported by default and also in the form #dSN… for N between 0 and 9.

```  
# d9821 #d0 #d-8290553
```

##### Hexadecimal

Hexadecimal integers (#16r) are supported in the form #xSN… for N between 0 and F.

```  
# x-00FF #x0 #x829CAFF3
```

##### Hexatridecimal

Hexatridecimal integers (#36r) are supported in the form #zSN… for N between 0 and Z.

```  
# z-QA5N #z0 #z+70M6Z8P
```
#### Longs

A long number is 128 bits.

```
100000000000000000000 -800000000000000000000  
```

#### Rationals

Rational numbers have a decimal integer numerator over a decimal integer denominator.

```  
3/4 -8/20  
```

#### Reals & Floats

Real numbers are 64 bit decimal floating-point numbers in scientific notation. A float is a sub type of real. Float numbers are 128 bits, have higher precision and a smaller range than real numbers. Floats can be used for monetary values. Float calculations must be made explicit by wrapping them in the float function , e.g. (+ (float 100) (float 200)), or suffixing the letter f after the number.

``` 
10.0 -92983.23749

0.001 -2342.0e-23

+2342.243 234.0e+0

54.50f 124.95f
```

#### Imaginaries

Imaginary numbers are decimal numbers having a floating point number suffixed by the letter "i" (representing the square root of -1).

```  
21i -5i 2.9i -9.93i  
```

#### Complexes

Complex numbers include a decimal real part plus a decimal imaginary part.

```  
55+34i -2.35+7i -32-14.3i

0+2i 75+i 0+i  
```

#### Unsigned

Unsigned decimal integers up to 64 bits are supported. They are suffixed by the letter "u"
```
0u 3u

18446744073709551615u 99999999999999999u
```

#### Infinity

The infinity data abstraction represents a positive infinite number.

```  
infinity  
```

#### Ninfinity

The ninfinity data abstraction represents a negative infinte number.

```  
ninfinity  
```

#### Undefined

The undefined data abstraction represents an impossible or undefined number.

```  
undefined  
```

### Time

Time is supported in several varieties: dates,epochs, intervals, moments, seconds, and ticks.

#### Dates

A date represents time as a universal time coordinate (YYYY-MM-DDThh:mm:ss.sZ).

```
2016-11-24T08:15:30-08:00

1990-01-10T09:30:00.001Z
```

#### Epochs

The epoch data abstraction represents time in unix epochs as a 64 bit integer value suffixed by the letter "p". An epoch represents the number of seconds since midnight January 1, 1970.

```  
10p 592p 60p  
```

#### Intervals

The interval data abstraction represents a time coordinate as two distinct time points . The lesser time point is separated from the greater time point by a tilde.

```
2012001005050000m~2025500000000000m 3s~10s

2012-05-19~2013-07-23 946684800u~1577836800u
```

#### Moments

The moment data abstraction represents time in nano-years (approximately 0.0031573275 seconds) as a 16 digit, 64 bit, integer value suffixed by the letter "m".

```
2025500000000000m -1m

2012001005050000m 3000m ; approximately 10 seconds
```


#### Seconds

The seconds data abstraction represents time in seconds as a 64 bit integer value suffixed by the letter "s".

```

10s 592s 60s  
```

#### Ticks

The tick data abstraction represents time in nanoseconds as a 64 bit integer value suffixed by the letter "t".

```
2342t 100000t  
```


#### Eternity

The eternity data abstraction represents an infinite amount of time in the future.

```
eternity  
```

#### Neternity

The neternity data abstraction represents an infinite amount of time in the past.

```  
neternity  
```

#### Indeterminate

The undefined data abstraction represents an impossible or undefined number.

```  
indeterminate  
```

### Identifiers

An identifier is an alphanumeric sequence of characters not delimited by quotes.

#### Symbols

A symbol is a variable, i.e., an identifier that has both a name and an associated value. In the Premise Language, symbols are literals starting with a question mark and ending with a sequence of numeric or alphanumeric characters. When symbols are declared their value is immediately set to an initial value. Referencing an undeclared symbol will cause a failure. Symbols are typically written in lowercase. Some symbols may be used as constants.. For example:

```
?height ?User.width ?length ?2
```

##### Constants

A constant is a symbol whose value cannot change. By convention constants are written in uppercase.

```
?MAX-LIMIT ?WIDTH-MIN ?DEFAULT-LENGTH
```

##### Aliases

A symbol alias is a pointer to a symbol. An alias allows a symbol to be passed as a reference parameter.

```
(alias ?MAX-LIMIT) (alias ?2)

[Alias :Symbol ?MAX-LIMIT] [Alias :Symbol ?2]
```

##### Symbol Scoping

Symbol scope refers to how the actual value of a symbol’s value is derived when a symbol is evaluated determined by the scope under which the symbol was defined. A symbol may have one of five scopes: global, module, lexical, dynamic, task, and restricted.

###### Global Scope

Global symbols are declared using the global function.
```
> (do (global ?X 1)

(function g (tell user ($$ ?X \s)) (set ?X 2))

(function f (global ?X 3)(g)))

(f)

(tell user ($ ?X ($))))

3 2 .: told
```

###### Module Scope

 A symbol may be scoped to the current module using the modular  function.

```
> (do (global ?X 1)

(function g (tell user ($$ ?X \s)) (set ?X 2))

(function f (modular ?X 3) (g)))

(f)

(tell user ($ ?X ($))))

3 1 .: told
```

###### Lexical Scope

Lexical scoping in SubThought Premise is achieved via the do or try functions. Multiple tasks may access the same lexical symbol. Do creates a new scope, let adds symbols to the existing scope.

```clojure 
> (do (global ?X 1)

(function g (tell user ($$ ?x \s)) (set ?x 2))

(function f (do (let ?x 3) (g)))

(f)

(tell user ($ ?X ($))))

3 1 

.: told

> (do (global ?X 1)

(function g (tell user ($$ ?x \s)) (set ?x 2))

(function f (let ?x 3) (g)))

(f)

(tell user ($ ?X ($))))

3 1 .: told
```

###### Dynamic Scope

 A dynamic scope creates temporary global symbols.

```
> (do (global ?X 1)

(function g (tell user ($$ ?X \s)) (set ?x 2))

(function f (dynamic {?x 3} (g)))

(f)

(tell user ($ ?X ($))))

3 2 .: told
```

###### Task Scope

 Symbols local to a particular task are shielded from changes by other tasks.

```
> (do (global ?X 1)

(function g (tell user ($$ ?x \s)) (set ?x 2))

(function f (local {?x 3} (g)))

(f)

(tell user ($ ?X ($))))

3 1 .: told
```

###### Restricted Scope

Rescricted scopes only shadow symbols and prohibit free symbols.

```
> (do (global ?X 1)

(function g (tell user ($$ ?x \s)) (set ?x 2))

(function f (only {?x} (g)))

(f)

(tell user ($ ?X ($))))

1 1 .: told
```

##### Symbol Assignment

Symbols may be bound to values in a variety of ways.

###### Assign

The assign macro declares and initializes symbols, returning the value of the last symbol.

```
> (assign ?X 1 ?Y 2 ?Z 3)

.: 3

> ?X ?Y ?Z

.: 1 2 3
```

###### Let

The let macro declares and initializes symbols, returning true.

```
> (let ?X 1 ?Y 2 ?Z 3)

.: true

> ?X ?Y ?Z

.: 1 2 3
```

###### <-- Before Tie

The before tie macro captures a symbol's return value before binding the symbol to an expression.

```
> (global ?X 1 ?Y 1 ?Z 1)

.: true

> (<-- ++ ?X)

.: 1

> ?X

.: 2
```

###### \--> After Tie

 The after tie macro captures a symbol's return value after binding the symbol to an expression .

```
> (global ?X 1)

.: true

> (--> + ?X 1)

.: 2

> ?X

.: 2
```

###### Let

The let macro declares symbols in the current environment and binds them to object property values, object method values, sequence positions, or functions, and then returns true.

```
> (relation Counter

:Value 0 :Resets 0 :Reclaim false

)

.: Counter

> (new Counter)

.: Counter1

> (let Counter1 :Value ?value)

.: true

> ?value

.: 0

> (let {a b c d e f g} 1 ?first # ?last)

.: true
```

###### Presume

The presume macro declares and initializes symbols in parallell, returning true.

```
> (presume ?X 1 ?Y 2 ?Z 3)

.: true

> ?X ?Y ?Z

.: 1 2 3
```

###### Tie

The tie macro updates declared symbols in parallel, and returns true.

```
> (tie ?X 1 ?Y (++ ?X) ?Z (++ Y))

.: [Failure :Name UnboundSymbol :Text "The symbol ?X is unbound."]

> (tie {?X ?Z} {2 2})

.: true

> ?X ?Y ?Z

.: 2 2 2
```

###### Set

The set macro updates declared symbols in tandem, returning the value of the last assignment.

```
> (set ?X 1 ?Y (++ ?X) ?Z (++ Y))

.: 3

> ?X ?Y ?Z

.: 1 2 3
```

#### Literals

Literals are non-numeric constants which evaluate to themselves. Typically, literals begin with an alphabetic or punctuation character (such as colon or exclamation point), and contain contiguous sequences of alphabetic, numeric, underscore or period characters. Literals provide names for functions, relationship prototypes, enumeration values, and so forth. Some examples of literals are as follows:

```
a one :2 three

a1 a12-34 hello-world thequickbrownfox

\* ! ::= -a-curious-literal
```

##### Structures

Structures are unpersisted ephemeral relationships, created with the structure function. One built in structure is Failure.

```  
> (structure Fault :What :Where :When)  


.: Fault  


> (Structure Message :Sender :Recipient :Content)  


.: Message  
```


###### Slots

Slots are literals preceded by a colon. Some examples are:

```  
:Height :Width :Length :321 ^  
```

The identifier slot is the caret character: ^ .

Slots hold data values. In relation definitions, slots are followed by values called defaults. In instances, slots are followed by actual values called terms. When no default or referent is present for a slot, the value nil is implied.

The following are examples of relationship prototypes with slots and defaults.

```
(relation Red

:Object corvette

:Size little )

  
(relation Phrase

:Saying "Who goes there"

:Count 14 )
```

The following are some examples of premises with slots and terms.

```  
[Red ^ Red56 :Object corvette :Size litte]

[Event ^ Event101 :Subject bird]

[Basket ^ Basket12 :Items {apple banana orange}]  
```

When a call has a relation slot as its first item and a premise or thought as the second item, the call will return value of the slot within the premise or from the thought.

```  
> (:Color [Fruit :Color Green])

  
.: Green

  
> (:Quantifier Fact35)  


.: Some  

```

##### Relations

A persisted relationship is comprised of a type literal, slots, methods, and default values. A thought premise has a relation literal, slots, methods, and actual values. Relationships are defined using the relation function. Thoughts are created using the new or the knew function. Finally, there are three kinds of slots for a Relationship: data slots, method slots, and identity slots.

The relation function is used to define a relationship. The relation definition starts with a left parenthesis, followed by the literal relation, followed by an identifier for the type name, followed by any relation dependencies (each dependency is preceded by the uses keyword), then the slots and default values, methods and function names, and finally ending with a right parenthesis.

A relationship prototype must be defined before a new thought can be formed. Consider the following definitions:

```  
> (relation Fruit

:Color

:Weight 1.0

!eat Fruiteat

)  


.: Fruit

  
> (relation Apple

uses Fruit

:Color red

)

.: Apple  


  
> (relation Delicious
      uses Apple
      :Color yellow       
    )

.: Delicious
```

###### The Identity Slot

Thoughts have an identity slot (^) that contains the identifier value which uniquely demarcates the thought. Some examples of thought identifiers are

```  
Sentence_1 Red_34 SOV_74

Vocalization_9202 Instance_983  
```

Thought premises also contain an identity slot. For example,

```  
> (premise Red1)

.: [Red ^ Red_1 :Object corvette :Size little]

> (premise Event_29)

.: [Event ^ Event_29 :subject bird]
```

A self reference value (@^) can be used when forming thoughts using the new function. Self (@^) is equivalent to a "this" variable in some structured languages such as C++, or the ?me variable in Premise.

```  
(new Car :make Dodge :model RAM :year 2010 :id @^)  
```

###### Method keys

Methods are literals preceded by an exclamation point. Some examples are:

```  
!action !cleanup !onNew !onOld  
```

Relationships have several built in methods which can be implemented by the developer: a constructor (!onNew), destructor (!onOld), copy method (!onCopy), and an update method (!onSet). The !onNew method initializes a premise. The !onOld method disposes of a premise.

Calling a method will look up the function name located in the method and invoke the function on the arguments. The methods cloneMe and ConceptAdd will be retrieved when invoked.
```
  
[MyObject !save saveMe !clone cloneMe]

[Concept :Datum 0 !add Conceptadd ]  
```

There are two ways of invoking a method. Methods are invoked using the call function or by using the method name as a function (i.e, by placing the method name first in a call followed by the instance containing the method). A method not found failure will be thrown if the instance does not contain the method.

```  
(call !start car255 ?myKey) ; invoking a method using call

(!start car255 ?myKey) ; invoking a method using the method name.  
```

When a call has a method as its first item and a premise or identifier as the second item, the call will return the value of applying the method to the remaining arguments.

```  
> (relation Foo

:Datum 100

!add2 FooaddTwo

)

  
.: Foo

> (function FooaddTwo {?me}

(==> ?me + :Datum 2)

)

.: FooaddTwo

  
> (new Foo :Datum 1000)

  
.: Foo_1

> (:Datum Foo_1)

  
.: 1000

> (!add2 Foo_1)

  
.: 1002
```

##### Resources

A resource is a literal which represents a tuple. Resources can be created for tasks, files, assortments, data connections, and so forth. Typically a resource will indicate the type of resource, followed by a hyphen, followed by an integer resource number.

```
File-45 Task-32 Data-988

Lexicon-87 Environment-67 Colors
```

###### Assortments

Assortments are resources that hold unordered elements, associations, bindings, or enumerations.

Collections

Collections are sets that contain only keys. They are created with the collection function.

```
> (collection

the quick brown fox 21 "over the" lazy dogs [MyObject ^ MyObject32] )

.: Collection-1
```

Configuration

Configurations are key value pairs that are persisted to a file. They are created with the configuration function.

```
> (configuration "file://localhost.com/c$/apps/SubThought Premise/"

"/mind/agent/delay" 35m

"/mind/activation/history/maximum" 15)

.: Configuration-1
```

Environments

Environments contain identifier to value bindings. They are created with the environment function.

```
> (environment nil

(symbol x) 32 times10 "(function times10 {?x} (\* ?x 10))" )

.: Environment-1
```

Enumerations

Enumerations contain literal elements. Each element of the enumeration has a position. By default the first element will have position one, the second two, and so forth. If any of the arguments to the enumeration function is numeric, then that argument will set the position for the preceding literal. Enumerations are created with the enumeration function.

```
> (enumeration Colors red orange yellow )

.: Colors

> (enumeration Controls clock 100 timer 200 start 300)

.: Controls
```

Ephemerons

Ephemerons are manifested structures created with the new function. A Fault ephemeron can be defined as follows. Because they are short lived, ephemerons are represented as premises, and do not have a unique identifier. They keys for an ephemeron are fixed and are defined by the structure the ephemeron instantiates.

```
> (new Fault :What AnError :Where RightHere :When Now)  


.: [Fault :What AnError :Where RightHere :When Now]  


> (new Message :Sender Me :Recipient Todd :Content "Hello There")

.: [Message :Sender Me :Recipient Todd :Content "Hello There"]
```

Thoughts

A relation is a prototype defines a fixed record structure. A thought is an instance of a relation that has predefined keys, and can be added to memory using the new function. Each thought instance has a literal identifier. In the case below, Apple1 and Delicious34 are identifiers for thoughts.  

```
> (new Apple :Weight 2.0)

.: Apple1

> (new Delicious)

.: Delicious34
```

Lexicons

Lexicons contain value to value associations. They are created with the lexicon function.

```
> (lexicon

{a b c} "123" the {" t" " th" "the" "he " "e "} :Every body )

.: Lexicon-1

> (entries Lexicon-1)

.: {{a b c} "123"}{the {" t" " th" "the" "he " "e "}}{:Every body}}
```

###### Continuations

Continuations enable jumps into functions. They are created with the continuation function.

```
> (function factorialhps {?n ?k}

(let ?a 1)

(continuation ?m ?a)

(if (<= ?n 0)

(continue ?k ?a)

else

(--> -- ?n)

(continue ?m (\* (++ ?n) ?a))))

.: factorialhps

> (function factorial {?n}

(let ?r nil)

(continuation ?k ?r)

(if (nil-p ?r) (factorialhps ?n ?k) else ?r))

.: factorial

> (factorial 5)

.: 120
```

###### Data

Data resources enable the use of information sources. They are created with the data function.

```
> (global ?Data (data driver sqlserver server "//servername" port 1433

database mydata user "myUid" password "123456")

.: Data-1

> (fetch ?Data "select top 2 empid, name, salary from employee")

.: {{1 "John Smith" 10.50}{2 "Jane Johnson" 12.00}}

> (disconnect ?Data)

.: disconnected
```
###### Files

File resources enable the reading and writing of files. They are created with the file function.

```
> (write (file name "quick.txt" seek 1) "The quick brown fox")

.: File-1

> (close file-1)

.: closed
```

###### Tasks

Tasks are expressions that can be evaluated in separate threads of execution. They are created with the task function.

```
> (task (/ 1000 57) (\*\* 4 20) (\*\* 4 20))

.: {Task-1 Task-2 Task-3}

> (complete task-1 task-2)

.: {Task-1 Task-2}

> (await task-1)

.: 17.54385964912281

> (await task-2)

.: 1099511627776

> (concurrent task-3)

.: {Task-3}

> (await task-3)

.: 1099511627776

> (free {task-1 task-2 task-3})

.: freed
```

###### Indices

Index resources are used to increased the speed of instance retrieval. They are created with the index function.

```
> (relation Car :Make :Model :Year)

.: Car

> (index Car :Make :Model)

.: CarIndex1

> (index Car :Model)

.: CarIndex2

> (new Car :Make A :Model M1)

.: Car1

> (with Car ^ as ?i :Model M1) list ?i)

.: {Car1}

> (drop CarIndex1)

.: dropped

> (drop CarIndex2)

.: dropped
```

##### Keyword Literals

Certain literals are keywords that have a distinctive meaning. For example,

The Truth keyword grouping represents a possible logical states..

```  
true false unknown  
```

##### Reserved Literals

The function literals that comprise the Premise Language are reserved and should not be redefined in their native modules since attempting to do so would redefine the behavior of the language.

##### Modules

Modules are name spaces. A module literal is used to avoid literal collisions and provide modularity in SubThought Premise code. Modules are delimited by dots (.) within a literal. There are several initial modules.

KB Foundational functions

DB Database functions

IO File & Messaging functions

Math Math functions

Tasks Task functions

User User defined functions

All modules are global, meaning that the modules cannot be concatenated or nested. Modules are declared with the module function.

## Sequences

Sequences are ordered groupings of values. The main function of a sequence is to group values into arrays, sets, or bags of items. The Premise Language provides functions for accessing sequences as a series of elements.

### Calls

A call is a parenthetical expression which when evaluated, will result in a value. For example, the expression (+ 1 2 3) is a call which when evaluated will result in the value 6. The first item in the expression is the left parenthesis, followed by a function literal followed by any actual parameters, followed by a right parenthesis. The function literal may be either a language intrinsic function or a user defined function. An empty call, (), returns itself.
```
(+ 1 2 3) (trim " abc ") ()
```

#### Functions

Functions (also called exonyms) are defined using function.

```
> (function foo {?a ?b}

(+ ?a ?b)

)

.: foo

  
> (function bar {?a ?b}

(\* ?a ?b)

)

.: bar
```

Functions are invoked by creating a call—wrapping the name and arguments in parentheses.
```
> (foo 10 20)  


.: 30

  
> (bar 10 20)  


.: 200  
```

##### Parameter Lists

There are several ways define the parameters to a function

1. No parameter list.

```
(function forgetEveryone

(each (with Person) old)

)
```

1. As a list containing zero parameters

```
(function helloWorld {}

(tell user "Hello World")

)
```

1. As a list containing one or more required parameters

```
(function addThem {?x ?y}

(+ ?x ?y)

)
```

1. As a list containing a variadic remainder parameter which contains all passed arguments.

```
(function addAll {& ?numbers}

(tell user ($ the sum of ?numbers is (apply + ?numbers) \\n))

)
```

1. As a list containing optional parameters.

```
(function result {+ ?y}

(--> default ?y 0)

(tell user ($ result = ?y \\n))

)
```

1. As a list containing optional parameters with default values.

```
(function result {+ ?y = 0}

(tell user ($ result = ?y \\n))

)
```

1. As a list containing required, optional, or remainder parameters.

```
(function result {?x + ?y = 1 & ?z}

(tell user ($ result = (apply \* (& ?x ?y ?z)) \\n))

)
```

1. As a list containing keyword parameters.

```
(function result {% ?color ?length = 0 ?width  = 0 ?height = 0}

(tell user ($ color ?color))

(tell user ($$ , \s ?length \s ?length , \s width \s ?width , \s height \s ?height) ))

)
```

1. Function parameters are automatically evaluated by default. Macro parameters are unevaluated by default.

```
(macro result {?x ?y ?z}

(tell user ($$ (eval ?x( ", " (eval ?y) ", " (eval ?z) \\n))

)
```

##### Parameter Specifications

Any required parameters are specified first. A failure is caused if a required parameter is not supplied with an argument when a function is called.

```
(function addThem {?x ?y} ; ?x and ?y are required.

"Add two numbers."

(+ ?x ?y)

)
```

The optional parameter sigil, the plus sign (+), precedes any optional ordered parameters. Optional parameters are processed sequentially and are bound to nil if no default values are specified.

```
(function AddTwoToFive {integer ?a integer ?b + integer ?c = 0 integer ?d = 0 integer ?e}

"Add between two and five numbers."

(apply + (& ?a ?b ?c ?d ?e))

)
```

Default values may immediately follow an optional parameter symbol. The default value sigil, the equal sign (\=), precedes a default value to a symbol. Default values may only be literals, times, numbers, or strings. The default value must not be a symbol, resource, tuple, call, or list.

```
(function addThem {+ ?x = 0 ?y = 0}; ?x and ?y both default to zero.

"Add two numbers."

(+ ?x ?y)

)
```

The keyword parameter sigil is the percent sign.  Any symbols following the sigil will have their symbol bound to the argument value 
following the corresponding slot named by the symbol. 
is a list containing a keyword pattern and symbol pair (e.g., % ?symbol will be bound to :slot value). 

```
(macro myFor {?y % ?as & ?body}

(eval (` (for , ?as in , ?y , ?body)))

)
```
A function or macro containing required keyword parameters would be called as follows
```
(myFor {Jane Jack Joe} :as ?name (tell user ($ ?name \\n)))

Keyword arguments are matched in any order they occur in the argument list if their formal parameters follow the keywords sigil.

(macro myStep { ' ?v % ?from  ?to ?z}  ?by = 1 & ?body}

(eval (` (step , ?v from , ?from to , ?to  (default , ?by 1) , ?body)))

)
```
A variadic parameter sigil, the ampersand (&), ties the remaining arguments together into a list for the subsequent symbol. Only one symbol is permitted after the ampersand. The remainder parameter will be bound to an empty list if no actual parameters are supplied.

```
(function AddTwoOrMore {?x ?y & ?z}

(if (void-p ?z)

(+ ?x ?y)

else

(apply + (& ?x ?y ?z)))

)
```

It would be called as follows

```
(myStep ?i to 100 by 2 from 1 (tell user ($ ?i \\n)))

In functions, all arguments are evaluated before the function body is applied. This is not the case for macros. Macro parameters remain unevaluated until they are explicitly evaluated with the eval function within the body of the macro definition.

(macro callLength {?f}

(ensure Call ?f)

(# (eval ?f))

)
```

More examples…

```
(function foo

"No parameter list."

(do nothing))

(function foo {}

"Zero length param list."

(do nothing))

(function foo {?x ?y}

"Fixed number of required parameters."

(+ ?x ?y))

(function foo {+ ?x = 0 ?y = 0}

"Optional parameters with default values."

(+ ?x ?y))

(function foo {?w + ?x ?y & ?z}

"Required, optional, and remaining parameters."

(--> default ?x 0)

(--> default ?y 0)

(apply + (& ?w ?x ?y ?z)))

(function foo {+ ?w = 0 ?x = 0 ?y = 0 & ?z }

"Optional and remaining parameters with default values."

(apply + (& ?w ?x ?y ?z)))

(macro define {?name ?args & ?body}

"Unevaluated parameters."

(eval (` (function , ?name , ?args , ?body))))
```

##### Auto-named Functions

Auto-named functions (also called endonyms) are created by omitting the function name in the definition. When the function name is omitted, the Premise Interpreter will automatically generate a function name for the function.

```  
> (function {?x ?y}

(\* ?x ?y)

)

.: fn-24

  
> (function {& ?args}

(apply \* ?args)

)

.: fn-25

  
> (function

(with Truck ^ as ?t

do (old ?t)))  


.: fn-26  

```

##### Anonymous Functions

Anonymous functions (i.e., also called anonyms) are implemented using given. An anonym expression can stand in for a named or auto-named function call.

```  
> ((given {?x ?y} (\* ?x ?y)) 2 3) ; same effect as (fn-24 2 3)

.: 6
```

##### Generators

A generator is a function that creates a series. Generators are created using the generator function. When a generator is invoked it will produce a series.

```  
> (generator generateABC {}

(yield a)

(yield b)

(yield c)

(stop))

.: generateABC

> (collect ?e in (generateABC) ?e)

.: {a b c}

> (generateABC)

.: {...}

```

##### Macros

A macro is a call that evaluates an expanded expression. Macros are defined using macro. The back quote function (`) expands an expression by substituting subexpressions that follow commas, then it evaluates the resultant expression.

```
> (macro plus {?a ?b}

(eval (` (+ , ?a , ?b)))

)

.: plus

  
> (macro prod {?a ?b}

(eval (` (\* , ?a , ?b)))

)

.: prod
```

Macros are invoked by wrapping the macro name and arguments in parentheses.

```
> (plus 10 20)

.: 30

  
> (prod 10 20)

.: 200
```

### Expressions

Expressions are sequences of zero or more variants without any delimiters. Expressions are usually found inside sequences such as lists, tuples, or calls.

an expression don't do that

another expression He said, Sure why not?

### Lists

Lists are ordered groupings of values which evaluate to themselves. Lists are malleable so they can be extended or reduced and elements can be inserted or deleted. This malleability allows lists to represent stacks or queues or orderings. The empty list, { }, may be used in code for clarity. Lists are created with the list function.

```
{a b c} {1 2 3} {}
```

### Vectors

Vectors are pipe (i.e., vertical bar) delimited sequences of numbers or literals. Bytes are not supported as a distinct data type; instead a byte is an integer written in base 16.

```
|0| |#nxFFE2C872| |#nxFF #nxE2 #nxC8 #nx72|
```

### Strings

Strings are sequences of characters delimited by double quotes. Characters are not supported as a distinct data type, instead characters are strings of length 1.

```
"a string" "don't do that"

"another string" "He said, 'Sure why not?'."
```

Backslashes provide character escaping. Doubling the backslash character within a string provides an escape for the backslash character. For Example \\\\ will represent a single \\. Other escape characters are as follows:


| Escape Sequences | Character Generated |
| --- | --- |
|     |     |
| \\\\ | \\  |
| \\' | '   |
| \\n | newline |
| \\t | tab |
| \\" | "   |
|     |     |

Character values can be generated using the backslash character. The octal values \\o0 to \\o177777, Unicode values \\u0000 to \\uFFFF, and decimal values \\d0 to \\d65535 can be contained in strings to select specific characters.

### Tuples
Tuples are sequences of variants delimited by square brackets. 

#### Premises

Premises are relationships comprised of a literal type and zero or more key-value pairs (called terms) enclosed in square brackets. For example `[Fault :What nil :Where nil :When nil]` is a tuple. Resources, ephemerons, and instances can all be represented as tuples.



Premises are tuples that represent language objects.

```
> (premise (new Fault :What "Printer Error" :Where "Line 287"

:When "2014-003-16T21:54"))

.: [Fault :What "Printer Error" :Where "Line 287" :When "2014-003-16T21:54"]

> (premise [Fault :What "Printer Error" :Where "Line 289" :When "2014-003-16T21:57"])

.: [Fault :What "Printer Error" :Where "Line 289" :When "2014-003-16T21:57"]
```

For a relationship or thought, the premise function will retrieve a premise representation of the relationship or thought. The uses keyword coalesces many relations into one. Consider the following example where the get function retrieves the instance E1.
```
> (relation A

:X 0

)

.: A

> (relation B

:Y 1

)

.: B

> (relation C

:Z 0  
)

.: C

> (relation D  
uses A uses B uses C

)

.: D  
<br/><br/>> (new D)

.: D1

> (premise D1)

.: [D ^ D1 :X 0 :Y 1 :Z 0]

> (relation E

uses D

:Z 2

)  


.: E

> (new E)  


.: E_1

> (premise E_1)

.: [E ^ E_1 :X 0 :Y 1 :Z 2]
```

#### Patterns

A pattern is a premise that is used to match thoughts. A pattern consists of a relation name or thought identifier list and some combination of slot bindings, slot tests, or both, enclosed within square brackets. A slot binding is a slot name, followed by as or each, followed by a symbol. A slot test is either a call containing a function that returns a boolean value, or a slot name, followed by a Boolean function name, followed by a value . Some examples of patterns are as follows:

```
[Prediction :What ?what :Start ?start] ; two slot bindings

[Hypothesis ^ ?me :If ?if :Then ?then] ; three slot bindings

[Solution as ?s :Duration > 5000t] ; one binding one test

Patterns can be used in with function calls in order to perform rule based inference. For example, we first create a relation and some instances like this:

> (relation Fact :All :Are)  
<br/>.: Fact

> (new Fact :All people :Are mortal)  
<br/>.: Fact_1

> (new Fact :All philosophers :Are people)  
<br/>.: Fact_2
```

Then the with expression can infer a conclusion

```
> (with [Fact :All as ?S :Are as ?M]

[Fact :All = ?M :Are ?P)]

get

(knew Fact :All ?S :Are ?P))

.: [Fact ^ Fact3 :All philosophers :Are mortal]

```
The patterns in the with expression above that matched the thoughts Fact_1 and Fact_2 are

```
[Fact :All ?M :Are ?P] matches Fact_1 and Fact_2

[Fact ^ ?f :All ?S (= (:Are ?f) ?M)] matches Fact_2 only.
```

Finally, the knew function attempts to find an existing thought whose slots match the values. If none are found, then the function creates a new thought.

```
> (knew Fact All ?S :Are ?P)  
<br/>.: Fact3
```

# 4\. Control Flow

The following expressions permit alterations to the normal sequential flow of expression evaluation.

## Conditional Expressions

Conditional expressions branch the flow of evaluation to alternate paths.

### if

The if macro provides branched conditional flow of evaluation.

```
> (if (= 1 2)

(tell user ($ An impossibility.))

(tell user ($ I'm certain. \\n))

or (= 2 1)

(tell user ($ Another impossibility.))

(tell user ($ Most definitely. \\n))

or (/= 1 1)

(tell user ($ A total absurdity.))

(tell user ($ Without a doubt. \\n))

else

(tell user ($ The world is right as rain. \\n))

HelloWorld)

The world is right as rain.

.: HelloWorld
```

### case

The case macro provides branching based on a value.

```
> (case red

of green (tell user ($ Nature's)) (tell user ($ glory. \\n))

of blue (tell user ($ A wondrous)) (tell user ($ beauty. \\n))

in {brown black purple indigo violet} (tell user ($ A fabulous selection. \\n))

else

(tell user ($ Hmmm... I didn't consider that one.))

(tell user ($ ($) Bravo. \\n))

Hmmm... I didn't consider that one. Bravo.

.: nil
```

### when

The when macro provides branched conditional flow of evaluation.

````
> (when (= 1 2)

(tell user ($ A truth.))

(tell user ($ An impossibility. \\n)))

An impossibility

.: told

> (when (= 1 1)

(tell user ($ Without a doubt. \\n))

(tell user ($ A total absurdity.)))

Without a doubt.

.: told
```

### try

The try macro provides exception handling or subroutine resumption.

```
> (try

(signal Failure :Name MyFault :Text "Failed Miserably")

learn ?failure

(tell user ($ Handled ?failure \\n))


finally

(tell user ($ Done. \\n)))


Handled [Failure :Name MyFault :Text "Failed Miserably"]

Done.

.: told 
> (try

(signal Mistake :Name MyFault :Text "Failed Miserably")

learn ?something

(tell user ($ Handled ?something \\n))


finally

(tell user ($ Done. \\n)))


Handled [Mistake :Name MyFault :Text "Failed Miserably"]

Done.

.: told 

> (proceed

(escape)

resume 

(tell user ($ Resumed execution \\n))

finally

(tell user ($ Done. \\n)))

Resumed execution

Done.

.: told

```
 
## Looping Expressions

Certain expressions are used to loop through a sequence or iterate over a series of values.

### loop

The do macro allows conditional repetition of one or more expressions.

```
> (global ?I 100)

.: true

> (loop (--> -- ?I) until (= ?I 90))

.: 90

> (loop (--> ++ ?I) while (< ?I 100))

.: 100

> (loop (--> -- ?i) repeat 100)

.: 0
```

### for

```
The for macro repeatedly binds one or more symbols through elements of a sequence.

> (for ?x in {hello world} (tell user ($$ ?x \s)))

hello world .: told

> (for ?x in "hello world" (tell user ($$ ?x \s)))

h e l l o w o r l d .: told

> (for ?k ?v in {a 1 b 2 c 3 d 4}

(tell user ($ ?k ($$ ?v ,))))

a 1, b 2, c 3, d 4, .: told

> (for ?x ?y ?z per {{a 1 $}{b 2 @}{c 3 #}{d 4 /})

(tell user ($ ?x ?y ($$ ?z ,))))

a 1 $, b 2 @, c 3 #, d 4 /, .: told
```

### step

The step macro increments or decrements a symbol over a series of numeric values.

```
> (step ?i from 5 to 9

(tell user ($$ "?i = " ?i ", " )))

?i = 5, ?i = 6, ?i = 7, ?i = 8, ?i = 9, .: told

> (step ?i from 100 to 50 by -10

(tell user ($$ "?i = " ?i ", " )))

?i = 100, ?i = 90, ?i = 80, ?i = 70, ?i = 60, ?i = 50, .: told

> (step ?i from 0 to 0.5 by 0.1

(tell user ($$ "?i = " ?i ", " )))

?i = 0, ?i = 0.1, ?i = 0.2, ?i = 0.3, ?i = 0.4, ?i = 0.5, .: told
```

### repeat

The repeat macro allows repetition of one or more expressions for a specified number of iterations.

```
> (repeat 1000 (--> ++ ?i))

.: 1100

> (repeat 5 (tell user ($$ hi \s))

hi hi hi hi hi .: told
```

### while

The while macro allows repetition of one or more expressions while a condition is true.

```
> (global ?N 0)

.: true

> (while (< ?N 5)

(tell user ($ ?N \\n))

(--> ++ ?N))

0

1

2

3

4

.: 5
```

### until

The until macro provides repetition of one or more expressions until a condition is true.

```
> (global ?S {a b c d 1 2 3 4} ?i 0 ?result {})

.: true

> (until (number-p (@ ?S (--> ++ ?i)))

(& ?result {{(@ ?S ?i) bar}}))

.: {{a bar}{b bar}{c bar}{d bar}}
```

## Escape Expressions

Escape expressions redirect the flow of control.

### assert

The assert macro transfers control to a prior try expression.

```
> (function multiply {?a ?b}

(confirm (datatype-p ?a number) since ($ ?a must be a number))

(confirm (datatype-p ?b number) since ($ ?b must be a number))

(\* ?a ?b))

.: multiply

> (multiply 10 banana)

.: [Failure :Name DataTypeFailure :Text "banana must be a number"]
```

### break

The break macro transfers control out of the containing loop.

```
> (do (step ?i from 1 to 10

(if (= ?i 3) (break nil))

(tell user ($ ?i \\n)))

(tell user ($ done \\n)))

1

2

done

.: nil
```

### continue

The continue macro transfers control to the next iteration of the containing loop.

```
> (for ?letter in "Premise"

(if (in "meis" ?letter) (continue))

(tell user ($ Letter is ($$ ?letter .) \\n)))

Letter is P.

Letter is r.

.: nil
```

### exit

The exit macro transfers control out of the current task. Whereas return may exit from a nested function, exit terminates the task. Exit can be thought of as a task level return.

```
> (async

(step ?x from 1 to 999999999

(if (> ?x 100) (exit exited))))

.: {Task-1}

> (await task-1)

.: exited

> (free task-1)

.: freed
```

### signal

The signal macro transfers control to an encompassing try expression on the stack.

> (function myFun

(try

(signal Failure :Name BadAttitude :Text "example")

learn ?f

(case (:Name ?f)

of BadAttitude

(tell user ($ Caught inside myFun. \\n))

(signal ?f)))

)

.: myFun

> (function main {& ?args}

(try

(myFun)

recover ?f

(case (:Name ?f)

of BadAttitude

(tell user ($ Caught inside main. \\n))))

)

.: main

> (main)

Caught inside myFun.

Caught inside main.

.: nil
```

### return

The return macro transfers control out of the current function.

```
> (function a {?i} (if (= ?i 5) (return nil)) (tell user ($ ?i \\n)))

.: a

> (function b {?i} (if (> ?i 4) (return 4 from b)) (tell user ($ ?i \\n)) (return 2))

.: b

> (function c {?k ?v} (return {?k ?v} from function))

.: c

> (function d (a 30))

.: d

> (do

(a 5)

(a 1)

(let ?i (b 5))

(tell user ($ ?i \\n))

(tell user ($ (@ (c 100 90) 2) \\n))

(d))

1

4

90

30

.: nil
```

### ensure

The ensure macro transfers control to an encompassing try expression if a type check fails.

```
> (function multiply {?a ?b}

(ensure number ?a number ?b)

(\* ?a ?b))

.: multiply

> (multiply 10 banana)

.: [Failure :Name EnsureType :Text "The value banana must be a number"]

> (multiply 10 5)

.: 50
```

### escape

The escape function transfers control to an encompassing proceed expression containing a resume and optional tag.

> (proceed

(escape)

resume

(tell user ($ Resumed execution \\n))

finally

(tell user ($ Done. \\n)))

Resumed execution

Done.

.: told



> (proceed

(escape there)

resume here

(tell user ($ Resumed execution here \\n))


resume there

(tell user ($ Resumed execution there \\n))
finally

(tell user ($ Done. \\n)))

Resumed execution there

Done.

.: told

```


### go

The go macro transfers control to a function to implement coroutines.
It pops the current location from the stack and pushes the target function's location.

```
> (relation Queue :Items {} :Capacity 10

!count (given {?me}(# (:Items ?me)))

!full-p (given {?me}(>= (!count ?me) (:Capacity ?me))))

.: Queue

> (function produce {?q}

(tell user ($ producing \\n))

(if (not (!full-p ?q))

(repeat (random 1 to (- (:Capacity ?q) (!count ?q)))

(enq ?q :Queue (new Item))))

(go consume ?q))

.: produce

> (function consume {?q}

(tell user ($ consuming \\n))

(if (more-p (:Queue ?q))

(repeat (random 1 to (# (:Queue ?q)))

(deliver (pop (:Queue ?q)))))

(either (void-p (:Queue ?q))

done

(go produce ?q))

> (produce (new Queue))

producing

consuming

producing

consuming

producing

consuming

producing

consuming

producing

consuming

producing

consuming

producing

consuming

producing

consuming

producing

consuming

producing

consuming

.: done
```


## Multitasking Expressions

The Premise Language facilitates asynchronous and concurrent expression evaluation.

### concurrent

The concurrent function runs expressions asynchronously and returns immediately.

```
> (concurrent (+ 1 2 3 4) (/ 1000 57))

.: {task-1 task-2}

> (await task-1)

.: 10

> (await task-2)

.: 17.54385964912281

> (free {task-1 task-2})

.: nil
```

### complete

The complete function executes expressions concurrently and returns after all have completed.

```
> (complete (step ?i from 0 to 50000000 (do nothing))

(step ?i from 1 to 10000000 (do nada)))

.: {Task-1 Task-2}

> (await task-1)

.: nothing

> (await task-2)

.: nada

> (free {task-1 task-2})

.: freed
```

### scatter

The scatter function applies functions in parallel and returns a list of non-nil results.

```
> (function double {?x} (\* ?x 2))

.: double

> (scatter {5} {++ -- double})

.: {6 4 10}

> (scatter {{the quick brown fox jumped over the lazy dogs}}

{except rest top last})

.: {{the quick brown fox jumped over the lazy }

{quick brown fox jumped over the lazy dogs}

{the}

{dogs}}

> (scatter {2 3 4} {+ \* -})

.: {9 24 -5}
```

# 5\. Code Examples

The following are simple examples demonstrating the language.

## Inference

Logical pattern matching and declarative inference.

```
(relation Statement

:All

:Are

)

(new Statement :All people :Are mortal)

(new Statement :All philosophers :Are people)

(with [Statement :All as ?s :Are as ?m]

[Statement :All = ?m :Are as ?p]

list

(knew Statement :All ?s :Are ?p))

> (relation Statement

:All

:Are

)

.: Statement

> (new Statement :All people :Are mortal)

.: Statement_1

> (new Statement :All philosophers :Are people)

.: Statement_2

> (with [Statement :All as ?s :Are as ?m]

[Statement :All = ?m :Are as ?p]

list

(knew Statement :All ?s :Are ?p))

.: {Statement3}

> (with Statement)

.: {[Statement ^ Statement_1 :All people :Are mortal]

[Statement ^ Statement_2 :All philosophers :Are people]

[Statement ^ Statement_3 :All philosophers :Are mortal]}

```

## Memoization

Memoization is the process of saving intermediate results for lookup rather than recomputation. Once a value has been computed, it can be memorized so that if the value is needed again, it can be easily retrieved rather than recomputed. The following example uses memoization in computing Fibonacci numbers.

```
> (relation Memoized

 :Number

  :Result

 )

.: Memoized

> (new Memoized :Number 0 :Result 0)

.: Memoized_1

> (new Memoized :Number 1 :Result 1)

.: Memoized_2

> (function fib {?n}

   (confirm (>= ?n 0) since

($ ?n must be zero or more.))

  (with

[Memoized  :Number as ?n :Result as ?r] ; if a matching instance exists

do

(return ?r)) ; then return, otherwise do nothing

(let ?result (+ (fib (- ?n 1)) (fib (- ?n 2))))

(new Memoized :Number ?n :Result ?result)

(return ?result)

)

.: fib

> (fib 7)

.: 13

> (with Memoized)  
<br/>.: {[Memoized ^ Memoized1 :Number 0 :Result 0]

[Memoized ^ Memoized_2 :Number 1 :Result 1]

[Memoized ^ Memoized_4 :Number 3 :Result 2]

[Memoized ^ Memoized_6 :Number 5 :Result 5]

[Memoized ^ Memoized_3 :Number 2 :Result 1]

[Memoized ^ Memoized_8 :Number 7 :Result 13]

[Memoized ^ Memoized_7 :Number 6 :Result 8]

[Memoized ^ Memoized_5 :Number 4 :Result 3]}
```


## Programming Patterns

Event driven programming.

```
> (structure Event

:Topic

:Content

)

.: Event

> (relation Fault

:Who

:What

:Where

:When

)

.: Fault

> (function dispatcher {?message}

(try

(let ?taken (take ?message)

?event (either (takeable-p ?taken) (@ ?taken) else nil)

(ensure Event ?event)

(let ?event :Topic as ?topic :Content as ?content)

(case ?topic

of Percept (onPerceptReceived ?content)

of Ping (onPingReceived ?content)

else

(sinal :Name BadTopic :Text ($ Unknown topic ?topic)))

(tell user ($ Handled ?message))

recover ?failure

(new Fault :Who Dispatcher :What ?failure :When (date)

:Where {dispatcher ?message}))

)

.: dispatcher

> (global ?URL (config "/application/eventUrlAndPort"))

.: true

> (listener ?URL dispatcher) ; creates a message loop

.: Listener-1

> (tell ?URL ($ (new Event :Topic Ping :Content {:Sent (moment)}))))

.: told

Handled [Event :Topic Ping :Content {:Sent 201804991265124m}]

> (free Listener-1 cancel yes)

.: freed
```

## Similarity Based Matching

The \~ and best language intrinsics perform similarity based comparisons to support case-based reasoning.

```
> (~ {a b c} {a d e})

.: 0.2

> (~ "a b c" "a d e")

.: 0.090909091

> (~ 57 890)

.: 0.00119904076738

> (best 2001 (range 1 to 1000000) 5)

.: {{2001 1} {2000 0.5} {2002 0.5} {1999 0.33333333333333333}

{2003 0.33333333333333333}}

> (best "this" {"that" "hat" "hit" "with" "isthmus"} 3)

.: {{"that" 0.11111111111111111} {"hat" 0.08333333333333333}

{"hit" 0.08333333333333333}}

## Asynchrony and Concurrency

The async, co, and task functions run expressions asynchronously, concurrently, or as required. The concurrence function co returns after all tasks have completed whereas the asynchronicity function async returns immediately after invocation. The task function creates a task for deferred execution. The functions each return a list of task handles.

> (concurrent (step ?i from 1 to 30000000 (do something)) ; runs asynchronously

(step ?j from 1 to 60000000 (do something-else)))

.: {Task-1 Task-2}

> (ready-p task-1)

.: false

> (await task-1)

.: something

> (await task-2 1000 timed-out) ; adding timeout and default args

.: timed-out

> (await task-2)

.: something-else

> (free {task-1 task-2})

.: freed

> (complete (step ?i from 1 to 30000000 (do someOtherThing)) ; runs concurrently

   (step ?j from 1 to 60000000 (do anotherThing)

    (step ?k from 1 to 100000000 (do oneLastThing))

.: {Task-3 Task-4 Task-5}

> (cancel task-5)

.: cancelled

> (await task-3 0 timed-out)

.: someOtherThing

> (await task-4 0 timed-out)

.: anotherThing

> (free {task-3 task-4})

.: freed  
<br/>> (function sayHello {}

(for ?c in "hello " (tell user ($ ?c))))

.: sayHello

> (global ?Tasks (task (sayHello) (sayHello) (sayHello) (sayHello)))

.: true

> (free (complete ?Tasks))

hhehelelohl lello l ol o .: freed

> (function sayHello {}

(critical printing

(for ?c in "hello " (tell user ($ ?c)))))

.: sayHello

> (set ?Tasks (task (sayHello) (sayHello) (sayHello) (sayHello)))

.: true

> (free (complete ?Tasks))

hello hello hello hello .: freed

> (undeclare ?Tasks)

.: undeclared
```

## Sequences

A sequence is a string, a list, a call, or a tuple. The language provides functions to manipulate sequences (e.g, # element, make, bind, for).

```  
> (@ "ABC" 2) ; find the second element of the string

.: "B"

> (@ {The quick brown fox jumped over the lazy dogs} 5)

.: jumped

> (copy {A B C} 1 X 3 Z)  ; copy list, replacing positions 1 and 3

.: {X B Z}

> (copy "ABC" 1 X 3 Z) ; copy string, replacing positions 1 and 3

.: "XBZ"

> ?v1

.: [Failure :Name UndefinedSymbol :Text "Symbol ?v is undefined."]

> (let {A B C} 1 ?v1 2 ?v2)

.: true  

> ?v1

.: A

> (let "ABC" 1 ?s1 2 ?s2)

.: true  

?s1

.: "A"

> ?s2

.: "B"  


> (for ?c in "the quick brown fox"

(tell user ($ ?c)))

the quick brown fox .: told

> (for ?n in {1 2 3}

(tell user ($$ (\* ?n 10) \s )))

10 20 30 .: told
```

## Tuples

Premises are tuples and there are specific functions to manipulate premises (e.g., get, let, set, zap).

```
> (relation Foo :Bar :Baz)

.: Foo

> (new Foo :Bar 100)

.: Foo_1

> (premise Foo_1)

.: [Foo ^ Foo_1 :Bar 100 :Baz nil]

> ?bar

.: [Failure :Name UndefinedSymbol :Text "Symbol ?bar is undefined."]

> (let (premise Foo_1) :Bar as ?bar)

.: true

> ?bar

.: 100

> (put Foo_1 :Baz "The quick brown fox")

.: Foo_1

> (zap Foo_1 :Bar)

.: Foo_1

> (premise Foo_1)

.: [Foo ^ Foo_1 :Bar nil :Baz "The quick brown fox"]

> (zap Foo_1)

.: Foo_1

> (premise Foo_1)

.: [Foo ^ Foo_1 :Bar nil :Baz nil]
```

## Assortments

Assortments are tuples that contain unordered items. Assortments such as collections, lexicons, environments, and enumerations are provided along with specific functions to manipulate them (e.g., add, cut, item, keys, put, the, tie, values, etc.).

```
> (lexicon q nil)

.: Lexicon-1

> (add Lexicon-1 "z" foo)

.: Lexicon-1

> (add Lexicon-1  84 nil)

.: Lexicon-1

> (entries Lexicon-1)

.: {{q nil}{'z' foo}{84 nil}}

> (cut Lexicon-1 "z")

.: Lexicon-1

> (entries Lexicon-1)

.: {{84 nil}{q nil}}

> (lexicon :Length 24 :Width 12 :Height 9 :Units inch)

.: Lexicon-2

> (@ Lexicon-2 :Length)

.: 24

> (@ Lexicon-2 :Width)

.: 12

> ?width

.: [Failure :Name UndefinedSymbol :Text "Symbol ?width is undefined."]

> ?height

.: [Failure :Name UndefinedSymbol :Text "Symbol ?height is undefined."]

(tie Lexicon-2 :Width ?width :Height ?height)

.: true

> ?width

.: 12

> ?height

.: 9

> (keys Lexicon-2)

.: {:Height :Length :Units :Width}

> (values Lexicon-2)

.: {inch 12 24 9}

> (enumeration Colors

red orange yellow green blue indigo violet)

.: Colors

> (@ Colors red)

.: 1

> (keys Colors)

.: {red orange yellow green blue indigo violet}

> (values Colors)

.: {1 2 3 4 5 6 7}

> (@ Colors green)

.: 4

> (entries Colors)

.: {{red 1}{orange 2}{yellow 3}{green 4}{blue 5}{indigo 6}{violet 7}}

> (enumeration Controls  

 

clock 100

timer 200

start 300)

.: Controls  

> (@ Controls timer)

.: 200

> (keys Controls)

.: {clock start timer}

> (collect ?key ?value per (sort (entries Controls) {< 2}) ?key)

.: {clock timer start}  


> (enumeration Highways

 Maine-Miami             ; defaults to 1

   Maine-Idaho              ; defaults to 2

   Michigan-Washington 10

   NewYork-Louisiana        ;will be 11

   Massachusetts-Oregon 20

   Ohfile-Florida             ; will be 21

   NewJersey-Oregon 30

   Michigan-Alabama

   NewJersey-California 40

   Michigan-Florida

   Maryland-Nevada  50

   Wisconsin-Louisiana

   Illinois-California 60

   Minnesota-Louisiana

   NorthCarolina-Arizona  70

   JeffersonHighway

   Georgia-California 80

   NorthDakota-Texas

   Florida-Texas 90

   Montana-Nevada

   Washington-California 101)

.: Highways  
<br/>> (sort (values Highways) <)

.: {1 2 10 11 20 21 30 31 40 41 50 51 60 61 70 71 80 81 90 91 101}

> (@ Highways NewJersy-California)

.: 40

## Rules

The rule function creates a rule that asynchronously match thoughts. Rules are run spontaneously when thoughts match the rule’s preconditions. There is no guarantee as to when or whether a particular rule will execute. The rule may be cancelled and reclaimed using the reclaim function.

> (reasoning)

.: false

> (reasoning on)

.: true

> (relation Summation :Result 0)

.: Summation

> (relation Addend :Value 0 :Status pending)

.: Addend

> (rule

(with [Summation ^ as ?sum]

[Addend ^ as ?add :Value as ?value :Status = pending]

do

(==> ?sum + :Result ?value)

(put ?add :Status added)))

.: Rule-1

> (new Addend :Value 5)

.: Addend_1

> (premise Addend_1)

.: [Addend ^ Addend_1 :Value 5 :Status pending]

> (new Summation)

.: Summation_1

> (premise Summation_1)

.: [Summation ^ Summation_1 :Result 5]

> (premise Addend_1)

.: [Addend ^ Addend_1 :Value 5 :Status added]

> (new Addend :Value 7)

.: Addend_2

> (premise Addend_2)

.: [Addend ^ Addend_2 :Value 7 :Status added]

> (premise Summation_1)

.: [Summation ^ Summation_1 :Result 12]

> (new Addend :Value 11)

.: Addend_3

> (premise Addend_3)

.: [Addend ^ Addend_3 :Value 11 :Status = added]

> (premise Summation_1)

.: [Summation ^ Summation_1 :Result 23]

> (free Rule-1)

.: freed

> (rule (with [Addend ^ as ?a :Status = added] do (old ?a)))

.: Rule-2

> (with Addend)

.: {}

> (with Summation)

.: {[Summation ^ Summation_1 :Result 23]}

> (old Summation_1)

.: gone

> (nix Summation)

.: nixed

> (nix Addend)

.: nixed

> (free (rules))

.: freed

> (reasoning off)

.: false
```

## Functions

Functions are defined using the function intrinsic. Function names may not be preceded by a question mark. Functions may have no parameter list, an empty parameter list, or a list containing, required, optional, remainder or keyword parameters.

```
> (function factorial {?n} ; named function with a parameter list

(reduce (range 1 to ?n) \*)

)

.: factorial

> (factorial 4)

.: 24

  
> (function prime-p {?n} ; named function with required parameter

(if (< ?n 2)

(return false)

else

(step ?i from 1 to (++ (ceiling (root ?n)))

(if (and (> ?i 1)(< ?i ?n)(zero-p (% ?n ?i)))

(return false))))

true

)

.: prime-p

> (prime-p 2)

.: true

> (prime-p 6)

.: false

> (function sum {& ?args} ; named function with a remaining parameter variable

(apply + ?args)

)

.: sum

> (sum 1 2 3 4)

.: 10

  
> (function addTwoToFive {?1 ?2 + ?3 = 0 ?4 = 0 ?5 = 0} ; named function with optional

(apply + (& ?1 ?2 ?3 ?4 ?5)) ; defaulted parameters

)

.: addTwoToFive

> (addTwoToFive 5 5)

.: 10

> (addTwoToFive 5 6 7 8)

.: 26

> (function addAll {?1 ?2 + ?3 = 0 ?4 = 0 & ?rest} ; named function with optional and

   (apply + (& ?1 ?2 ?3 ?4 ?rest)) ; remainder parameters

)

.: addAll

> (addAll 1 2 3 4 5 6 7 8 9 10)

.: 55

> (function forgetIt {?relation} ; named function  
(confirm (relation-p ?prototye) since ($ ?relation must be a relation.))  
 (for ?x in (with ?relation) (old ?x))

forgotten

)

.: forgetIt

> (with Statement)

.: {[Statement ^ Statement1 :All people :Are mortal]

[Statement ^ Statement2 :All philosophers :Are people]

[Statement ^ Statement3 :All philosophers :Are mortal]}

> (forgetIt Statement)

.: forgotten

> (with Statement)

.: {}

> (function {& ?args} ; auto-named function with

(apply \* ?args) ; remaining parameter variable

)

.: fn-1

  
> (fn-1 1 2 3 4)

.: 24  
<br/>> (function transitivity ; no parameters  
(with [Statement :All as ?a :Are as ?b]  
[Statement :All = ?b :Are as ?c]  
do  
(knew Statement :All ?a :Are ?c))  
)  
<br/>.: transitivity

> (macro myFor {?x {in ?y} & ?body} ; a required keyword parameter  
  (eval (` (apply for (& , ?x in , ?y , ?body))))

)

.: myFor

> (myFor ?name in {Jane John Sally} (tell user ($ ?name \\n)))

Jane

John

Sally

.: told

> (macro myStep {?v {from ?a} {to ?z} + {by ?i = 1} & ?body} ; optional keyword  
  (eval (` (step , ?v from , ?a to , ?z by , ?i , ?body))))

)

.: myStep

> (myStep ?x from 1 to 5 by 2 (tell user ($ ?x \\n)))

1

3

5

.: told  
<br/>

> (myStep ?x from 1 to 5 (tell user ($ ?x \\n)))

1

2

3

4

5

.: told  

```

## Modules

Modules are literals that encapsulate function definitions. In practice, a function has a module preceding the function name, (as in “module.function”). Functions having a module in their literal are “qualified”. Functions without modules are “unqualified”. The module intrinsic creates modules. The extend intrinsic allows more function definitions to be added to a module. The using intrinsic sets or returns the current module. The require intrinsic allows functions to be visible between modules.

```
> (modules) ; view the modules collection

.: {Base DB IO Math Tasks User}

> (use User) ; work in a specific module

.: User

> (module Arithmetic ; define a new module Arithmetic

(function sum {& ?args}

(apply + ?args)

)

)

.: Arithmetic

> (modules)

.: {Arithmetic Base DB IO Math Tasks User}

> (sum 1 2 3 4) ; is sum visible from user module?

.: [Failure :Name ArgumentValue :Text "The function sum isn't found"]

> (Arithmetic.sum 1 2 3 4) ; is fully qualified function visible?

.: 10

> (require Arithmetic as a) ; user module requires definitions

.: Arithmetic

> (sum 1 2 3 4) ; now sum is visible

.: 10

> (a.sum 1 2 3 4) ; now a.sum is visible

.: 10

> (Arithmetic.sum 1 2 3 4) ; still accessible as Arithmetic.sum

.: 10

> (extend Arithmitic

(function product {& ?args} ; add a new function

(apply \* ?args)

)

)

.: Arithmetic
```

## Delegates

```
Delegates are functions that are passed as parameters to other functions.

> (relation Product :Name :Price )

.: Product

> (relation Cart :Items {} !total CartTotal )

.: Cart

> (function CartTotal {?me ?SubTotDelegate ?TotalDelegate ?DiscountDelegate}

(ensure Cart ?me Function ?SubTotDelegate Function ?TotalDelegate

Function ?DiscountDelegate)

(let ?subTotal (sum (map (:Items ?me) :Price)))

(?SubTotDelegate ?subTotal)

(?DiscountDelegate ($ Discounts applied.\\n))

(?TotalDelegate (:Items ?me) ?subTotal))

.: CartTotal

> (relation Program :Cart !onNew (given {?me}(put ?me :Cart (new Cart))))

.: Program

> (function main {& ?args}

(let ?me (new Program))

(enq (:Cart ?me) :Items (new Product :Name Cheese :Price 5.50))

(enq (:Cart ?me) :Items (new Product :Name Bread :Price 7.00))

(enq (:Cart ?me) :Items (new Product :Name Milk :Price 4.65))

(enq (:Cart ?me) :Items (new Product :Name Eggs :Price 5.95))

(tell user ($ Your total is

(!total (:Cart ?me)

(given {?sub}(tell user ($ The subtotal is ?sub \\n)))

(given {?products ?sub}

(if (> (# ?products) 3)

(\* ?sub 0.90)

else ?sub))

(given {?msg}(tell user ?msg)))

\\n \\n)))

.: main

> (main)

The subtotal is 23.10

Discounts Applied.

Your total is 20.7

.: told
```

## Poker Hand Analyzer

This function tells what kind of poker hand each player has.

```
> (enumeration Suits

Clubs Diamonds Hearts Spades

)

.: Suits

> (enumeration Ranks

Ace Two Three Four Five Six Seven

Eight Nine Ten Jack Queen King Joker

)

.: Ranks

> (relation Card

:Rank

:Suit

:Dealt

)

.: Card

> (relation Player

:Order

:Cards {}

:Hand Unknown

)

.: Player

> (function setup

(repeat 2 ; use 2 decks

(for ?suit ?i per (entries Suits)

(for ?rank ?j per (entries Ranks)

(if (/= ?rank Joker) (new Card :Rank ?rank :Suit ?suit)))))

(let ?order 0)

(repeat (random 2 to 8) (new Player :Order (--> ++ ?order)))

)

.: setup

> (function deal

(with Card ^ as ?card do (set ?card :Dealt false))

(with Player ^ as ?player do (set ?player :Cards {} :Hand unknown))

(let ?players (which Player sort :Order < )

?cards (shuffle (which Card)))

(repeat (config "/Game/Poker/CardsPerPlayer")

(for ?player in ?players

(let ?card (pop ?cards))

(enq ?player :Cards ?card)

(put ?card :Dealt true)))

)

dealt

)

.: deal

> (enumeration Hands

Nothing

OnePair

TwoPairs

ThreeOfAKind

Straight

Flush

FullHouse

FourOfAKind

StraightFlush

)

.: Hands

> (function analyze

(with [Player ^ as ?p :Cards as ?cards :Hand = Unknown]

[Card ^ as ?c1 (contains ?cards ?c1) :Suit as ?s :Rank as ?r]

(let ?n (position Ranks ?r))

[Card ^ as ?c2 (contains ?cards ?c2) :Suit = ?s :Rank = (@ Rank (+ ?n 1))]

[Card ^ as ?c3 (contains ?cards ?c3) :Suit = ?s :Rank = (@ Rank (+ ?n 2))]

[Card ^ as ?c4 (contains ?cards ?c4) :Suit = ?s :Rank = (@ Rank (+ ?n 3))]

[Card ^ as ?c5 (contains ?cards ?c5) :Suit = ?s :Rank = (@ Rank (+ ?n 4))]

(/= ?c1 ?c2 ?c3 ?c4 ?c5)

do

(put ?p :Hand StraightFlush))

(with [Player ^ as ?p :Cards as ?cards :Hand = Unknown]

[Card ^ as ?c1 (contains ?cards ?c1) :Rank = ?r]

[Card ^ as ?c2 (contains ?cards ?c2) :Rank = ?r]

[Card ^ as ?c3 (contains ?cards ?c3) :Rank = ?r]

[Card ^ as ?c4 (contains ?cards ?c4) :Rank = ?r]

(/= ?c1 ?c2 ?c3 ?c4)

do

(put ?p :Hand FourOfAKind))

(with [Player ^ as ?p :Cards as ?cards :Hand = Unknown]

[Card ^ as ?c1 (contains ?cards ?c1) :Rank as ?m]

[Card ^ as ?c2 (contains ?cards ?c2) :Rank = ?m]

[Card ^ as ?c3 (contains ?cards ?c3) :Rank = ?m]

[Card ^ as ?c4 (contains ?cards ?c4) :Rank as ?n (/= ?m ?n)]

[Card ^ as ?c5 (contains ?cards ?c5) :Rank = ?n]

(/= ?c1 ?c2 ?c3 ?c4 ?c5)

do

(put ?p :Hand FullHouse))

(with [Player ^ as ?p :Cards as ?cards :Hand = Unknown]

[Card ^ as ?c1 (contains ?cards ?c1) :Suit as ?s]

[Card ^ as ?c2 (contains ?cards ?c2) :Suit = ?s]

[Card ^ as ?c3 (contains ?cards ?c3) :Suit = ?s]

[Card ^ as ?c4 (contains ?cards ?c4) :Suit = ?s]

[Card ^ as ?c5 (contains ?cards ?c5) :Suit = ?s]

(/= ?c1 ?c2 ?c3 ?c4 ?c5)

do

(put ?p :Hand Flush))

(with [Player ^ as ?p Cards ?cards :Hand = Unknown]

[Card ^ as ?c1 (contains ?cards ?c1) :Rank as ?r]

(let ?n (position Ranks ?r))

[Card ^ as ?c2 (contains ?cards ?c2) :Rank = (@ Ranks (+ ?n 1))]

[Card ^ as ?c3 (contains ?cards ?c3) :Rank = (@ Ranks (+ ?n 2))]

[Card ^ as ?c4 (contains ?cards ?c4) :Rank = (@ Ranks (+ ?n 3))]

[Card ^ as ?c5 (contains ?cards ?c5) :Rank = (@ Ranks (+ ?n 4))]

(/= ?c1 ?c2 ?c3 ?c4 ?c5)

do

(put ?p :Hand Straight))

(with [Player ^ as ?p :Cards as ?cards :Hand = Unknown]

[Card ^ as ?c1 (contains ?cards ?c1) :Rank as ?n]

[Card ^ as ?c2 (contains ?cards ?c2) :Rank = ?n]

[Card ^ as ?c3 (contains ?cards ?c3) :Rank = ?n]

(/= ?c1 ?c2 ?c3)

do

(put ?p :Hand ThreeOfAKind))

(with [Player ^ as ?p :Cards as ?cards :Hand = Unknown]

[Card ^ as ?c1 (contains ?cards ?c1) :Rank as ?m]

[Card ^ as ?c2 (contains ?cards ?c2) :Rank = ?m]

[Card ^ as ?c3 (contains ?cards ?c3) :Rank as ?n (/= ?m ?n))]

[Card ^ as ?c4 (contains ?cards ?c4) :Rank = ?n]

(/= ?c1 ?c2 ?c3 ?c4)

do

(put ?p :Hand TwoPairs))

(with [Player ^ as ?p :Cards as ?cards :Hand = Unknown]

[Card ^ as ?c1 (contains ?cards ?c1) :Rank as ?m]

[Card ^ as ?c2 (contains ?cards ?c2) :Rank = ?m]

(/= ?c1 ?c2)

do

(put ?p :Hand OnePair))

(with [Player ^ as ?p :Cards as ?cards :Hand = Unknown]

do

(put ?p :Hand Nothing))

ready

)

.: analyze

> (do (setup) (deal) (analyze))

.: ready
```

## OPS5 Comparison

The OPS5 programming language was developed by Charles Forgy in the late 1970s. OPS is an acronym for "Official Production System" and it is a rule based programming language primarily used for expert system development. The following is an OPS5 program that implements a model of cars.

### OPS5
```
(literalize car

age ; new or old

condition ; good or junk

)

(p old-not-junk

(car ^age old ^condition <> good)

\--->

(write (crlf) that is believable))

(p good-not-old

(car ^age <> old ^condition good)

\--->

(write (crlf) that is possible))

(p new-and-junk

(car ^age new ^condition junk)

\--->

(write (crlf) There are no new, junk cars))

(copy car ^age new ^condition good)
```

### SubThought Premise

```
(relation Car

:Age ; new or old

:Condition ; good or junk

)

(rule old-not-junk

when [Car :Age = old :Condition /= good]

do (tell user ($ that is believable \\n)))

(rule good-not-old

when [Car :Age /= old :Condition = good]

do (tell user ($ that is possible \\n)))

(rule new-and-junk

when [Car :Age = new :Condition = junk]

do (tell user ($ There are no new, junk cars \\n)))

(new Car :Age new :Condition good)
```

## CLIPS Comparison

The C Language Integrated Production System, CLIPS, was developed in 1985 by NASA and was based on Charles Forgy's OPS languages and the Automated Reasoning Tool language from Inference Corporation. The example below is derived from <https://en.wikipedia.org/wiki/CLIPS>.

### CLIPS

```
(deftemplate problem

(slot name)

(slot status))

(defrule rule1

(problem (name ignitionkey) (status on))

(problem (name engine) (status wontstart))

(problem (name headlights) (status don’twork))

\=>

(confirm (problem (name battery) (status faulty))))

(deffacts troubleshooting

(problem (name ignitionkey) (status on))

(problem (name engine) (status wontstart))

(problem (name headlights) (status don’twork)))
```

### SubThought Premise

```
(relation Problem

:Name

:Status

)

(rule rule1

when [Problem :Name = ignitionKey :Status = on]

[Problem :Name = engine :Status = WontStart]

[Problem :Name = headlights :Status = DontWork]

do

(knew Problem :Name battery :Status faulty)

)

(function troubleshooting

(new Problem :Name ignitionKey :Status on)

(new Problem :Name engine :Status WontStart)

(new Problem :Name headlights :Status DontWork)

)

(troubleshooting)
```

## SQL Comparison

Structured Query Language (SQL) is a language for programming relational database management systems (RDMS). SQL was first described by Edgar F. Codd in 1970.

### Relationships

In Structured Quey Language, entities and the relationships among them are central to the languge. Entities (and relationships) are defined by Tables which have Columns.

#### SQL

```SQL 
CREATE TABLE Region (

RegionID INTEGER NOT NULL,

Name VARCHAR(50) NOT NULL

);

CREATE TABLE Country (

CountryID INTEGER NOT NULL,

Name VARCHAR(50) NOT NULL

);

CREATE TABLE Customer (

CustomerID INTEGER NOT NULL AUTOINCREMENT,

RegionID INTEGER NOT NULL,

CountryID INTEGER NOT NULL,

);

CREATE TABLE Order (

OrderID INTEGER NOT NULL AUTOINCREMENT,

CustomerID VARCHAR(10)

);

CREATE TABLE Category (

CategoryID INTEGER NOT NULL AUTOINCREMENT,

CategoryName VARCHAR(100) NOT NULL,

Description MEDIUMTEXT

);

CREATE TABLE Product (

ProductID INTEGER NOT NULL AUTOINCREMENT,

ProductName VARCHAR(100) NOT NULL,

CategoryID INTEGER,

UnitsInStock FLOAT,

UnitPrice FLOAT

Discontinued BIT

);

CREATE TABLE Employee (

EmployeeID INTEGER NOT NULL AUTOINCREMENT,

EmployeeName VARCHAR(100) NOT NULL,

ReportsTo INTEGER,

Sold FLOAT

);
```

#### SubThought Premise

```clojure 
(relation Region

:Name

)

(relation Country

:Name

)

(relation Customer

:Region

:Country

)

(relation Order

:CustomerId

)

(relation Category

:CategoryId

:CategoryName

:Description

)

(relation Product

:ProductId

:ProductName

:CategoryId

:UnitsInStock

:UnitPrice

:Discontinued false

)

(relation Employee

:EmployeeId

:EmployeeName

:ReportsTo

:Sold

)
```

### Select All

A select all query retrieves all attributes of an entity.

#### SQL

```sql 
SELECT \*

FROM Category
```
#### SubThought Premise

```
(which Category)
```

### Selecting a single column

In SQL a single column is selected by specifying the name of the column in a select query.

#### SQL

```sql 
SELECT CategoryName

FROM Category
```

#### SubThought Premise
```clojure
(with [Category as ?c]

list (:CategoryName ?c))

(with [Category :CategoryName as ?n]

list ?n)
```

### Selecting multiple columns

In SQL multiple columns are selected by naming each column in a select query.

#### SQL

```sql 
SELECT CategoryName, Description

FROM Category
```

#### SubThought Premise

```clojure
(with [Category :CategoryName as ?n :Description as ?d]

list {?n ?d})
```

### Selecting a calculated column

A calculated column is one in which a function is applied to one or more existing columns in a table.

#### SQL

```sql  
SELECT LENGTH(CategoryName)

FROM Category  
```

#### SubThought Premise

```clojure 
(with [Category :CategoryName as ?n]

list (# ?n))
```

### Selecting distinct values

#### SQL

```sql 
SELECT DISTINCT LENGTH(CategoryName)

FROM Category
```

#### SubThought Premise

```clojure 
(distinct

(with [Category :CategoryName as ?n]

list (# ?n)))
```

### Selecting a scalar value

#### SQL

```  
SELECT MAX(LENGTH(CategoryName))

FROM Category  
```

#### SubThought Premise

```
(max (with [Category :CategoryName as ?n]

list (# ?n)))
```

### Filtering results by Equality

#### SQL

```
SELECT \*

FROM Product

WHERE UnitsInStock = 0
```

#### SubThought Premise

```
(which Product

:UnitsInStock = 0)
```

### Filtering results by Inequality

#### SQL

```
SELECT \*

FROM Product

WHERE NOT (UnitPrice > 10)
```

#### SubThought Premise

```
(which Product

:UnitPrice as ?p

(not (> ?p 10)))

(which Product

:UnitPrice <= 10 )
```

### Filtering results by a range

#### SQL

```
SELECT \*

FROM Product

WHERE UnitPrice BETWEEN 5 AND 9
```

#### SubThought Premise

```
(which Product

:UnitPrice as ?u

(<= 5 ?u 9))
```

### Multiple filter conditions

#### SQL

```
SELECT \*

FROM Product

WHERE Discontinued = 1

AND UnitsInStock <> 0
```

#### SubThought Premise

```
(which Product

:Discontinued 1

:UnitsInStock not 0)
```

### Order by value ascending

#### SQL

```
SELECT \*`

FROM Product

ORDER BY UnitPrice
```

#### SubThought Premise

```
(which Product

sort :UnitPrice < )
```

### Order by value descending

#### SQL

```
SELECT \*

FROM Product

ORDER BY UnitPrice DESC
```

#### SubThought Premise

```
(which Product

sort :UnitPrice > )
```

### Limit number of results

#### SQL

```
SELECT TOP 5 \*

FROM Product

ORDER BY UnitPrice
```

#### SubThought Premise

```
(top (which Product

sort :UnitPrice < )

5)
```

### Paged results

#### SQL

```
WITH part1 AS (

SELECT \*

FROM Product

ORDER BY UnitPrice)

SELECT \*

FROM part1

WHERE RRN(part1) BETWEEN 5 AND 10
```

#### SubThought Premise

```
(mid (which Product

sort :UnitPrice < )

5

10)
```

### Group by value

#### SQL

```
SELECT TOP 100 UnitPrice

FROM (SELECT Product.UnitPrice,

COUNT(\*) AS Count

FROM Product

GROUP BY Product.UnitPrice)

ORDER BY Count DESC
```

#### SubThought Premise

```
(with (top (with [Product as ?p :UnitPrice as ?u]

list {:UnitPrice ?u

:Count (with [Product :UnitPrice as ?u] tally)}

sort :Count > )

100) each ?x

list (:UnitPrice ?x))
```

### Inner Join

#### SQL

```
SELECT p.\*

FROM Product p,

Category c

WHERE c.CategoryName = "Beverages" AND

c.CategoryID = p.CategoryID
```

#### SubThought Premise

```
(with

[Product ^ as ?p :CategoryName = "Beverages" :CategoryId as ?id]

[Category :Categoryid = ?id]

list (premise ?p))
```

### Left Join

#### SQL

```
SELECT c.CustomerID, COUNT(o.OrderID)

FROM Customer c

LEFT JOIN Order o

ON o.CustomerID = c.CustomerID

GROUP BY c.CustomerID
```

#### SubThought Premise

```
(with

[Customer :CustomerId as ?i]

list {:CustomerId ?i :Count (with [Order :CustomerId = ?i] tally)}

(with

[Customer :CustomerId as ?i]

[Order :OrderId as ?j]

(left ?i ?j)

group {?i (when (any ?i) 1 0)}

by 1 into ?group

list {:CustomerId (@ ?group 1)

:Count (summation ?pair in (rest ?g) (@ ?pair 2)) }
```

### Concatenate

#### SQL

```
SELECT customer.CompanyName

FROM Customer AS customer

WHERE customer.CompanyName LIKE "A%’

UNION ALL

SELECT customer.CompanyName

FROM Customer AS customer

WHERE customer.CompanyName LIKE "E%’
```

#### SubThought Premise

```
(union

(with [Customer :CompanyName as ?n] (like ?n "A%") list ?n)

(with [Customer :CompanyName as ?n] (like ?n "E%") list ?n))
```

### Create, Update and Delete

#### SQL

```
INSERT INTO Category (CategoryName, Description)

VALUES ("Merchandising", "Cool products");

INSERT INTO Product (ProductName, CategoryID)

SELECT TOP (1) "Red Jacket", CategoryID

FROM Category

WHERE CategoryName = "Merchandising";

UPDATE Product

SET Product.ProductName = "Green Jacket"

WHERE Product.ProductName = "Red Jacket";

DELETE FROM Product

WHERE Product.ProductName = "Green Jacket";

DELETE FROM Category

WHERE Category.CategoryName = "Merchandising";
```

#### SubThought Premise

```
(new Category :CategoryName "Merchandising"

:Description "Cool Products")

(new Product :ProductName "Red Jacket"

:CategoryId (each Category ^ as ?c

:CategoryName "Merchandising"

give (:CategoryId ?c)))

(with [Product ^ as ?p :ProductName = "Red Jacket"]

do (put ?p :ProductName "Green Jacket"))

(with [Product ^ as ?p :ProductName = "Green Jacket"]

do (old ?p))

(with [Category ^ as ?c :CategoryName = "Merchandising"]

do (old ?c))
```

### Recursive Query

#### SQL

```
WITH EmployeeHierarchy (EmployeeID,

LastName,

FirstName,

ReportsTo,

HierarchyLevel) AS

( SELECT EmployeeID

, LastName

, FirstName

, ReportsTo

, 1 as HierarchyLevel

FROM Employees

WHERE ReportsTo IS NULL

UNION ALL

SELECT e.EmployeeID

, e.LastName

, e.FirstName

, e.ReportsTo

, eh.HierarchyLevel + 1 AS HierarchyLevel

FROM Employees e

INNER JOIN EmployeeHierarchy eh

ON e.ReportsTo = eh.EmployeeID

) SELECT \*

FROM EmployeeHierarchy

ORDER BY HierarchyLevel, LastName, FirstName
```

#### SubThought Premise

```
(relation EmployeeHierarchy

:EmployeeId :LastName :FirstName :ReportsTo :HierarchyLevel )

(with (union

(with [Employee ^ as ?e :ReportsTo is nothing :EmployeeId as ?i

:LastName as ?n :FirstName as ?f]

list (knew EmployeeHierarchy :EmployeeId ?i :LastName ?n

:FirstName ?f :HierarchyLevel 1))

(with

[EmployeeHierarchy ^ as ?eh :EmployeeId as ?i :HierarchyLevel as ?h]

[Employee ^ as ?e :EmployeeId as ?j :LastName as ?n :FirstName as ?f

:ReportsTo ?i]

list (knew EmployeeHierarchy :EmployeeId ?j :LastName ?n

:FirstName ?f :HierarchyLevel (+ ?h 1))))

as ?result

list (premise ?result)

sort :HierarchyLevel < :LastName < :FirstName < )
```

# 6\. Foundation Modules

The Premise Language is divided into several modules which contain built-in (i.e., intrinsic) functions. Each module has a particular area of responsibility. For example, the IO module facilitates communication while the knowledge base module declares foundational functions.

### DB

This module provides functions that manage external database communications.

### IO

This module contains functions which manage messaging, files, and the console.

### KB

This module provides the basic control structures and special forms of the language.

### Math

This module provides arithmetic, trigonometric, and statistical functions.

### Meta

This module contains the global environment.

### Tasks

This module has functions that manage asynchronous and concurrent tasks.

### User

This module contains the user's default environment.

# 7\. Quick Reference

'''
A synopsis of each intrinsic function follows.

| No | Signature | Description |
| --- | --- | --- |
| 1   | (\-- number ) | Decrements a number by 1. |
| 2   | (\- number … ) | Subtraction. |
| 3   | (@ container place … ) | Retrieves elements from a sequence or assortment. |
| 4   | (\# container) | Returns the number of elements. |
| 5   | ($ value … ) | Creates a new string with intervening spaces . |
| 6   | ($$ value … ) | Creates a new string by eliding arguments. |
| 7   | (% command arguments ) | Performs an operating system command |
| 8   | (& value … ) | Merges arguments into a new sequence. |
| 9   | (&& value … ) | Mergs arguments into a new sequences and removes nils. |
| 10  | (\* number number … ) | Mulitplication. |
| 11  | (\*\* base exponent) | Exponentiation. |
| 12  | (/ dividend divisor … ) | Division. |
| 13  | (// number degree) | Nth Root. |
| 14  | (/~ value1 value2) | Calculates the dissimilarity between two values. |
| 15  | (/= value1 value2 … ) | Returns true if any values are not equal. |
| 16  | (~ value1 value2) | Calculates the similarity between two values. |
| 17  | ( ' variant ) | Quotes a variant. |
| 18  | ( \` variant ) | Expands a variant by substituting values. |
| 19  | (+ number number . . . ) | Addition. |
| 20  | (++ number ) | Increments a number by 1. |
| 21  | (<-- function symbol value … ) | The value before tying a symbol to a new value. |
| 22  | (< value value … ) | True if each value is less than the next. |
| 23  | (<= value value … ) | True if each value is less or equal to the next. |
| 24  | (<== container function place value … ) | The value before replacement. |
| 25  | (\= value value … ) | True if each value is equal to the next. |
| 26  | (\==> container function place value … ) | The value after replacement. |
| 27  | (> value value … ) | True if each value is greater than the next. |
| 28  | (\--> function symbol value … ) | The value after tying a symbol to a new value. |
| 29  | (\>= value value … ) | True if each value is greater or equal to the next. |
| 30  | (\n quantity) | Returns a string containing one or more new lines. |
| 31  | (\\s quantity) | Returns a string containing one or more spaces. |
| 32  | (^ thought) | Returns a thought identifier. |
| 33  | (abolish symbols environment ) | Deletes symbols from an environment. |
| 34  | (abort tasks ) | Forcibly terminates one or more tasks |
| 35  | (about) | Provides system and version information. |
| 36  | (abs number) | Calculates the absolute value. |
| 37  | (absent url ) | True if a file, folder, or ur does notl exist. |
| 38  | (acosecant number geometry metrum) | Calculates the inverse cosecant. |
| 39  | (acosine number geometry metrum) | Calculates the inverse cosine. |
| 40  | (acotangent number geometry metrum) | Calculates the inverse cotangent. |
| 41  | (actual symbol) | Returns the underlying symbol referenced by an alias. |
| 42  | (add assortment entry … ) | Modifies an assortment by adding entries. |
| 43  | (address url) | Returns the address of a URL web resource. |
| 44  | (agent job url handler delay) | Creates an agent. |
| 45  | (alias symbol) | Returns a reference to a symbol. |
| 46  | (align sequence ordering) | Returns a sorted list using the provided ordering. |
| 47  | (all condition … ) | True if all relevant knowledge satisfies all of the conditions. |
| 48  | (alphabetic-p value) | True if the first position of a string is alphabetic. |
| 49  | (alphanumeric-p value) | True if the first position of a string is whitespace. |
| 50  | (and truth truth … ) | Logical conjunction. |
| 51  | (any condition … ) | True if some relevant knowledge satisfies all of the conditions. |
| 52  | (append sequence value … ) | Inserts values at the end of a sequence. |
| 53  | (apply function arguments environment) | Applies a function to a list of arguments. |
| 54  | (arguments what ) | Returns a list of arguments to a call or task. |
| 55  | (arity function kind) | Returns the number of symbols in a function's parameter list. |
| 56  | (array dimensions option) | Returns a multi dimensional list. |
| 57  | (asecant number geometry metrum) | Calculates the inverse secant. |
| 58  | (asine number geometry metrum) | Calculates the inverse sine. |
| 59  | (ask who message timeout default ) | Sends a message to a recipient and awaits a response. |
| 484 | (assert premise … ) | Adds premises to the knowledge base. |
| 60  | (assign assignment … ) | Adds symbols in tandem to the current environment. |
| 61  | (assume premise … ) | Adds premises to the knowledge base. |
| 62  | (atangent number geometry metrum) | Calculates the inverse tangent. |
| 63  | (attach knowledge ) | Registers a knowledge base. |
| 64  | (average symbol … binding sequence expression … ) | The arithmetic mean of a sequence. |
| 65  | (avg value …) | The arithmetic mean. |
| 66  | (await task timeout default) | Returns the result of a task. |
| 67  | (before-p interval1 interval2 tolerance) | True if an interval finishes before a second interval. |
| 68  | (beginning interval) | Returns the beginning instant of an interval |
| 69  | (best probe candidates option ... ) | Returns the best matching candidates. |
| 70  | (beyond sequence position ) | True if a position is outside a sequence. |
| 71  | (big value ) | Converts a value to a big number. |
| 72  | (bind container assignment … ) | Assigns symbols to values in sequences or assortments. |
| 73  | (bion name work ) | Returns a resource that hosts a cluster of cells for doing tasks. |
| 74  | (bindings pattern ) | Returns a list of symbol value pairs for an environment or premise. |
| 75  | (bitwise number op … ) | Performs bitwise operations. |
| 76  | (bound function) | Returns the symbols that are bound in a function. |
| 77  | (bound-p symbol) | True if a symbol has a value. |
| 78  | (bracket truth) | Returns 1 if a truth expression is true, 0 otherwise. |
| 79  | (break value) | Terminates a loop. |
| 80  | (busy-p task) | True if a task has not completed. |
| 81  | (but sequence quantity) | Creates a subsequence of all except the last elements. |
| 82  | (bye) | Terminates the interpreter. |
| 83  | (call value … ) | Creates an unevaluated call. |
| 84  | (can expression result error ) | Evaluates an expression while suppressing failures. |
| 85  | (cancel tasks option … ) | Cooperatively cancels tasks. |
| 86  | (cancelled-p task) | True if a task has been cancelled. |
| 87  | (canonify variant ) | Makes equal values identical. |
| 88  | (capitalize string option) | Capitalizes a string. |
| 89  | (case probe clause … else-clause) | Branches execution based on a value. |
| 90  | (categorize sequence predicate …) | Creates a list of equivalence sets. |
| 91  | (cede alias ) | Transfers a value between symbols. |
| 92  | (ceiling number) | Rounds a number towards positive infinity. |
| 93  | (cell bion work ) | Returns a resource that hosts tasks. |
| 94  | (channel task ) | Returns a url to the arguments of a task. |
| 95  | (char unicode) | Converts a Unicode value into a one position string. |
| 96  | (choose sequence selector transform) | Returns the arguments satisfying a function. |
| 97  | (clear container) | Eliminates all entries from an assortment or sequence. |
| 98  | (clip value minimum maximum) | Returns a value within a clipped range. |
| 99  | (clone atom modification … ) | Clones an atom with possible modifications. |
| 100 | (close url) | Closes a file or data url. |
| 101 | (closure scope type name params expression …) | Creates a function or macro with a defined environment. |
| 102 | (coalesce symbol … gate expression … ) | Returns a merged sequence. |
| 103 | (collect symbol … gate expression … ) | Returns a transformed sequence. |
| 104 | (collection element … ) | Returns an unorderd collection of elements. |
| 105 | (combine assortment entry … ) | Creates a new assortment by combining entries. |
| 106 | (common sequences) | Creates a sequence of common elements among subsequences. |
| 107 | (comparable-p value1 value2 ) | Returns true if the values can be compared. |
| 108 | (compare value1 value2) | Returns &lt; (less), = (equal), or &gt; (greater). |
| 109 | (complete expression … ) | Runs expressions concurrently until completion. |
| 110 | (complex real imaginary) | Converts a value to a complex number. |
| 111 | (compose functions arguments) | Applies functions in reverse order using the arguments. |
| 112 | (conceive knowledge ) | Creates a knowledge base. |
| 113 | (concurrent expression … ) | Evaluates expressions asynchronously. |
| 114 | (configuration url association ... ) | Creates a configuration file. |
| 115 | (confirm condition since reason ) | Tests that a condition is true. |
| 116 | (confute condition since reason ) | Tests that a condition is false. |
| 117 | (connect data ) | Connects to a data resource. |
| 118 | (constant assignment … ) | Creates a constant. |
| 119 | (contains assortment value ) | True if a value is present in an assortment. |
| 120 | (continue result) | Continues to the next iteration of a loop. |
| 121 | (convertible-p value taxon) | True if the value can be converted to the taxon. |
| 122 | (copy sequence count ) | Copies a sequence. |
| 123 | (copyright) | Displays copyright information. |
| 124 | (correlate list1 list2) | Finds the correlation coefficient of two lists. |
| 125 | (cosecant number geometry metrum) | Calculates the cosecant. |
| 126 | (cosine number geometry metrum) | Calculates the cosine. |
| 127 | (cotangent number geometry metrum) | Calculates the cotangent. |
| 128 | (count symbol … binding sequence as counter expression … ) | Counts the iterations and returns the last expression. |
| 129 | (critical locks option … expression …) | Serializes evaluations across regions of code. |
| 130 | (cut assortment key … ) | Removes elements from assortments by key. |
| 131 | (data option … ) | Creates a data url. |
| 132 | (date yr mth day hrs mins secs zone zmins) | Creates a new date or returns the current date. |
| 133 | (declared-p symbol environment) | True if a symbol exists in an environment. |
| 134 | (decode source format) | Decodes a string. |
| 135 | (default value … ) | Returns the first non-nil value. |
| 136 | (definitions environment ) | Retrieves literal value pairs in an environment. |
| 137 | (defunct function) | Undefines a function in a module. |
| 138 | (degrees radians) | Converts radians into degrees. |
| 139 | (delete sequence value … ) | Modifies sequence by deleting values. |
| 140 | (dependencies module) | Returns a module's dependencies. |
| 141 | (deq container place option) | Removes an element from an embedded sequence. |
| 142 | (describe literal) | Returns descriptions of a literal. |
| 143 | (detach knowledge ) | Unregisters a knowledge base. |
| 144 | (difference sequence1 sequence2 operation) | Returns the difference of two sequences. |
| 145 | (did expression ) | Evaluates an expression and surpresses failures. |
| 146 | (digit number position) | Returns the digit in the specified position of a number. |
| 147 | (digit-p value) | True if the first position of a string is a digit. |
| 148 | (digits number) | Returns the digits comprising a number. |
| 149 | (dimensions sequence) | Returns the lengths of each dimension in a sequence. |
| 150 | (discard module) | Discards a module. |
| 151 | (disjoint-p sequence sequence … ) | True if no elements are common among sequences. |
| 152 | (distinct sequence ) | Creates a new sequence without duplicate elements. |
| 153 | (dstribute sequence function result) | Applies a function to a sequence in parallel. |
| 154 | (divide dividend divisor default) | Performs safe division. |
| 155 | (divisible-p dividend divisor) | True if the divisor evenly divides the dividend. |
| 156 | (do expression … ) | Creates a lexical scope. |
| 157 | (done) | Terminates a generator. |
| 158 | (drop index) | Removes a relation index. |
| 159 | (duplicate source target option) | Duplicates a file or contents of a folder. |
| 160 | (during-p interval1 interval2 tolerance) | True if an interval occurs within a second interval. |
| 161 | (dynamic assignments expression … ) | Creates a dynamic environment for symbols. |
| 162 | (e) | Returns Euler's number, 2.718281828459045. |
| 163 | (each symbol … binding reversal sequence … premises option … action ) | Combines for and with to iterate over sequences to match patterns against the knowledge base. |
| 164 | (encode source format) | Encodes a string. |
| 165 | (enq container place entry) | Inserts an element into an embedded sequence. |
| 166 | (ensure check … ) | Performs type checking. |
| 167 | (entries assortment ) | Retrieves key value pairs for an assortment. |
| 168 | (enumeration name element … ) | Defines an enumerated assortment. |
| 169 | (enumerations) | Returns a list of all enumerations. |
| 170 | (environment parent entry … ) | Creates a new context for symbols and functions. |
| 171 | (epoch time) | Returns a Unix epoch or the current epoch. |
| 172 | (eradicate knowledge ) | Deletes a knowledge base. |
| 173 | (erase file option … ) | Deletes files or folders. |
| 174 | (escape) | Escapes to the next resume tag in the stack. |
| 175 | (eval expression environment ) | Evaluates an expression. |
| 176 | (even-p number) | True if the number is even. |
| 177 | (every symbol … binding sequence expression … test) | True if a predicate is true for every element in a sequence. |
| 178 | (exactly quantity of sequence clause within margin ) | True if a number of elements satisfy a clause. |
| 179 | (exchange sequence substitution … ) | Creates a new sequence with values swapped. |
| 180 | (excludes sequence element option … ) | True if a sequence does not contain an element. |
| 181 | (exists-p value) | True if a value is a thing.. |
| 182 | (exit value) | Explicitly ends a task using a return value. |
| 183 | (exponential number significand) | Calculates the base ten exponent of a number. |
| 184 | (expression value … ) | Creates an expression. |
| 185 | (extend module expression … ) | Adds new definitions to a module. |
| 186 | (facility name parameters expression … ) | Creates a private function in a module. |
| 188 | (few symbol … binding sequence expression … test) | True if a predicate is true for less than half the elements in a sequence. |
| 189 | (file option … ) | Opens or creates a file. |
| 190 | (files option …) | Returns a list of file names. |
| 191 | (fill symbol from start to end by increment with expression) | Fills a list with the result of an expression. |
| 192 | (filter sequence predicate ) | Returns a sequence of elements that satisfy a predicate. |
| 193 | (find features candidates option ... ) | Returns the best matching candidates. |
| 194 | (finishes-p interval1 interval2 tolerance) | True if two intervals finish together. |
| 195 | (finishing interval) | Returns the finishing instant of an interval. |
| 196 | (fix declaration … ) | Adds symbols to the current environment |
| 197 | (float value ) | Converts a value to a floating number. |
| 198 | (floor number) | Rounds a number towards negative infinity. |
| 199 | (fold symbol … in sequence into expression … ) | Tranforms a sequence into a value. |
| 200 | (folder option … ) | Creates or locates a folder in the file system. |
| 201 | (folders option … ) | Returns a list of sub folders. |
| 202 | (for symbol … binding reversal sequence … expression … ) | Iterates over the elements in a sequence. |
| 203 | (forever expression … ) | Repeatedly evaluates expressions. |
| 204 | (forgo dependency module) | Removes a dependent module. |
| 205 | (format template value … ) | Formats a string. |
| 206 | (fractional number) | Returns the fractional portion of a number. |
| 207 | (free resources ) | Releases resources. |
| 208 | (full first second ) | True if values are equal or either value is nil. |
| 209 | (function scope name params returning expression … ) | Creates a public function in a module. |
| 210 | (functions module) | Returns a list of functions defined in a module. |
| 211 | (gather symbol … binding sequence expression … test) | Returns a sequence of elements that satisfy a predicate. |
| 212 | (generator name parameters expression … ) | Creates a series generator. |
| 213 | (get container key … ) | Retrieves a value using one or more keys. |
| 214 | (given { parameter … } expression … ) | Creates an anonymous function. |
| 215 | (global assignment … ) | Creates global symbols. |
| 216 | (globals) | Creates list of global symbols. |
| 217 | (go function argument … ) | Transfers control to a function. |
| 219 | (grok theory) | Evaluates expressions in a url or file. |
| 220 | (group list by key … into symbol expression … ) | Combines sublists by position or key. |
| 221 | (halt compute ) | Terminates a cell or bion. |
| 223 | (has assortment key ) | True if a key is present in an assortment. |
| 224 | (hash value option … ) | Computes a hash code. |
| 225 | (help function) | Describes a function. |
| 226 | (hyperlink option … ) | Creates a hyperlink. |
| 227 | (id resource ) | Returns a resource number. |
| 228 | (identical-p value value … ) | True if all values occupy the same memory location. |
| 229 | (identity value) | Returns the value itself. |
| 230 | (idle duration) | Pauses for a specified interval. |
| 231 | (if condition expression … or-clause … else-clause) | Branched conditional evaluation. |
| 232 | (imaginary value) | Converts a value to an imaginary number. |
| 233 | (in value container option … ) | True if a value is in a sequence or assortment. |
| 234 | (includes sequence element option … ) | True if a value is in a sequence. |
| 235 | (index relation slot … ) | Creates an index on slots of a relation. |
| 236 | (indices relation ) | Returns a list of indices for a relation. |
| 237 | (infix sequence delimeter) | Creates a new sequence with interposed delimeters. |
| 238 | (inside value ) | Creates an expression from a sequence or assortment. |
| 239 | (insert sequence position value … ) | Creates a new sequence by nserting values. |
| 240 | (insort sequence value option … ) | Inserts a value into a sorted sequence. |
| 241 | (instantiate expression ) | Creates an expression with premises in place of thoughts. |
| 242 | (integer value ) | Converts a value to an integer. |
| 243 | (interleave sequence sequence … ) | Merges arguments into a new sequence. |
| 244 | (intersection sequence sequence … ) | Creates a sequence of common elements. |
| 245 | (intersects-p sequence sequence … ) | True if any elements are common among sequences. |
| 246 | (interval start finish) | Creates a time interval. |
| 247 | (into relation thoughts) | Creates new thoughts based on existing thoughts. |
| 248 | (invoke call environment) | Invokes a call. |
| 249 | (is value predicate) | True if the value is true or if the applied predicate returns true. |
| 250 | (junction scope name params expression … ) | Creates a public function where arguments are evaluaed in parallel. |
| 251 | (key assortment value ) | Finds the key for a value in an assortment. |
| 252 | (keys assortment ) | Creates a list of keys for an assortment. |
| 253 | (keywords) | Creates the list of Premise keywords. |
| 254 | (knew relation criterion … ) | Finds or creates a thought. |
| 255 | (knowledge option … ) | Finds or creates a knowledge base. |
| 256 | (known pattern … option … ) | True if the patterns match. |
| 257 | (lacks assortment key ) | True if a key is absent from an assortment. |
| 258 | (last sequence count) | Creates a subsequence of the last elements. |
| 259 | (left first second ) | True if values are equal or the second value is nil. |
| 260 | (let manner assignment ... ) | Adds symbols to the current environment. |
| 261 | (lexemes string) | Creates an uppercase string with spaces between words. |
| 262 | (lexicon association … ) | Creates a lexicon. |
| 263 | (lexicons) | Creates a list of all lexicons. |
| 264 | (license) | Prints the software license. |
| 265 | (like sequence pattern) | Compares a pattern to a sequence. |
| 266 | (list value … ) | Creates a list. |
| 267 | (literal value) | Creates a literal. |
| 268 | (local assignments expression … ) | Creates a task level scope. |
| 269 | (location symbol) | Sets a symbol to the current location. |
| 270 | (log number base) | Logarithm. |
| 271 | (long value) | Converts a value to a long number. |
| 272 | (loop expression … gate ) | Repeatedly evaluates expressions. |
| 273 | (lowercase string) | Converts a string to lower case. |
| 274 | (macro name parameters expression … ) | Creates a public macro in a module. |
| 275 | (macros module) | Creates a list of macros defined in a module. |
| 276 | (make prototype term … ) | Creates a record by creating a relationship if it does not exist. |
| 277 | (map sequence ... function) | Applies a function to elements across sequences. |
| 278 | (max value … ) | Finds the maximum element. |
| 279 | (maximum symbol … binding sequence expression … ) | Finds the maximum element. |
| 280 | (may expression ) | Evaluates an expression while surpressing failures. |
| 281 | (median value …) | Finds the middle value of a sequence. |
| 282 | (meets-p interval1 interval2 tolerance) | True if an interval finishes when a second interval starts. |
| 283 | (meron value) | Returns the meronomic prototype of a value. |
| 284 | (meron-p value meron) | True if the value is a meron or is of the specific meronomic type. |
| 285 | (meronomy value) | Returns the meronomic prototypes of a value. |
| 286 | (method scope name params expression … ) | Creates a public method in a prototype. |
| 287 | (mid sequence start distance ) | Copies a subsequence of a sequence. |
| 288 | (min value … ) | Finds the minimum element. |
| 289 | (minimum symbol … binding sequence expression … ) | Finds the minimum element. |
| 290 | (missing assortment value ) | True if a value is absent from an assortment. |
| 291 | (mod dividend modulus) | Finds the remainder after division. |
| 292 | (modular module expression … ) | Evaluates expressions in module's scope. |
| 293 | (module name definition … ) | Creates a module. |
| 294 | (modules) | Creates a list of known modules. |
| 295 | (moment units secs mins hours days year ) | Creates a moment or returns the current moment. |
| 296 | (more-p sequence) | True if a container has more than zero elements. |
| 297 | (morph arguments functions) | Applies functions in succession using the arguments. |
| 298 | (most symbol … binding sequence expression … test) | True if the predicate is true for more than half of the elements in a sequence. |
| 299 | (move source destination) | Moves or renames one or more files. |
| 300 | (my) | Returns the current cell resource. |
| 301 | (nall condition … ) | True if not all relevant knowledge satisfies all of the conditions. |
| 302 | (nand truth truth … ) | Negated logical conjunction. |
| 303 | (negative-p number) | True if a number is negative. |
| 304 | (nevery symbol … binding sequence expression … test) | True if the predicate is false for any element in the sequence. |
| 305 | (new prototype term … ) | Creates a record. |
| 306 | (next series) | Advances a series to the next element. |
| 307 | (ngrams string length) | Creates a list of substrings. |
| 308 | (nix prototype) | Deletes a prototype. |
| 309 | (no condition … ) | True if no relevant knowledge satisfies all of the conditions. |
| 310 | (none symbol … binding sequence expression … test) | True if the predicate is false for all sequence elements. |
| 311 | (nor truth truth … ) | Negated logical disjunction. |
| 312 | (not value predicate) | True if a value is false, or if the applied predicate returns false. |
| 313 | (nothing) | Returns nothing. |
| 314 | (null-p value) | True if a value is not a thing.. |
| 315 | (odd-p number) | True if a number is odd. |
| 316 | (old thought) | Deletes a thought. |
| 317 | (omit sequence value … ) | Creates a new sequence with values removed. |
| 318 | (on condition true-case false-case ) | Branched conditional evaluation. |
| 319 | (only symbols expression … ) | Creates a restricted scope. |
| 320 | (open url) | Opens a file or data url. |
| 321 | (or truth truth … ) | Logical disjunction. |
| 322 | (out value sequence option … ) | True if a value is absent from a sequence. |
| 323 | (overlaps-p interval1 interval2 tolerance) | True if an interval finishes after a second interval starts. |
| 324 | (pad sequence length value side ) | Creates a new padded sequence. |
| 325 | (parameters what ) | Returns a list of parameters for a function, call, or task. |
| 326 | (partition sequence pivot comparer) | Creates a list of equivalence sets for a pivot element. |
| 327 | (path folder separator file) | Concatenates a folder and file name. |
| 328 | (pattern expression … ) | Creates a pattern containing the supplied expressions. |
| 329 | (perform environment method instance … ) | Invokes a method within an environment. |
| 330 | (pi) | Returns 3.141592653589793. |
| 331 | (pick sequence quantity) | Creates a list of randomly selected elements. |
| 332 | (pipe option … ) | Creates a pipe. |
| 333 | (pop sequence position ) | Returns the element removed from a sequence. |
| 334 | (posit module url) | Writes module expressions to a url. |
| 335 | (position sequence element option … ) | Finds the position of an element or subsequence in a sequence. |
| 336 | (positions sequence) | Returns positions of an element in a sequence or position value pairs. |
| 337 | (positive-p number) | True if a number is greater than zero. |
| 338 | (premise value ) | Creates a premise representation of a value. |
| 339 | (probability events A operation B) | Calculates the probability over a series. |
| 340 | (proceed … resumption … finally … ) | Evaluates expressions and resumes from an escape. |
| 341 | (product symbol … binding sequence expression …) | Multiplies an expression over a range of values. |
| 342 | (punctuation-p string) | True if the first position of a string is punctuation. |
| 343 | (push sequence value position ) | Modifies a sequence by inserting a value. |
| 344 | (put container entry … ) | Updates values in an assortment or sequence. |
| 345 | (qualified module function) | Prepends a module to a function name. |
| 346 | (qualifiers identifier) | Creates a list of modules associated with an identifier. |
| 347 | (quantify sequence predicate option … ) | Returns a quantifier for elements satisfying a test. |
| 348 | (quantity symbol … binding sequence expression … test) | Returns the number of elements satisfying a test. |
| 349 | (radians degrees) | Converts degrees to radians. |
| 350 | (radix number base ) | Converts a number to a base. |
| 351 | (random lower to upper precision) | Creates a random number. |
| 352 | (range first to last by increment) | Creates a list of numbers. |
| 353 | (rational numerator denominator) | Converts values to a rational number. |
| 354 | (read file count bits) | Creates a string or stream. |
| 355 | (ready-p task) | True if a task has completed. |
| 356 | (real value) | Converts a value to a real number. |
| 357 | (reasoning toggle) | Toggles asynchronous rule execution. |
| 358 | (reclaim) | Performs garbage collection. |
| 359 | (reduce sequence function) | Converts a sequence into a value. |
| 360 | (relation name inclusion … definition … ) | Creates a relation. |
| 361 | (relations) | Returns a list of defined relations. |
| 362 | (release locks) | Releases locks on critical sections. |
| 363 | (remove assortment value … ) | Creates a new assortment by removing values. |
| 364 | (repeat count expression … ) | Loops a specified number of times. |
| 365 | (replace container entry … ) | Creates a new assortment or sequence by updating values. |
| 366 | (require module as moniker from url …options …) | Retrieves an absent module from a url. |
| 367 | (reset series) | Resets a series for reuse. |
| 368 | (resize sequence length default) | Modifies the length of a sequence. |
| 369 | (rest sequence skip) | Creates a subsequence of all except the first elements. |
| 370 | (retract rules) | Eliminates rules. |
| 371 | (return value from function) | Terminates a function call. |
| 372 | (reverse sequence) | Creates a reversed sequence. |
| 373 | (right first second ) | True if values are equal or the first value is nil. |
| 374 | (rip assortment value … ) | Removes elements from assortments by value. |
| 375 | (round number) | Rounds a number to the nearest integer. |
| 376 | (rule name properties when premises option … action … ) | Creates a rule. |
| 377 | (rules) | Creates a list of all rules. |
| 378 | (same value value … ) | True if all values are equal or contain equal elements. |
| 379 | (scale list scalar … function) | Applies a function to a list of numbers and scalar values. |
| 380 | (scatter arguments functions) | Applies functions in parallel returning a list of results. |
| 381 | (scope keyval ... ) | Finds an environment or gets the current environment. |
| 382 | (seal prototype) | Prohibits new records. |
| 383 | (secant number geometry metrum) | Calculates the secant of the number. |
| 384 | (seconds seconds) | Creates a seconds value or returns seconds since year zero. |
| 385 | (seek file position) | Repositions a file resource to a new read/write location. |
| 386 | (self) | Returns the currently executing task resource. |
| 387 | (separator kind) | Creates a separator string. |
| 388 | (series iterable) | Creates a series. |
| 389 | (service url handler) | Creates and starts a web service. |
| 390 | (set assignment ... ) | Assigns symbols to values in tandem. |
| 391 | (settings url association ... ) | Creates a configuration file.. |
| 392 | (sever assortment key … ) | Creates a new assortment by removing keys. |
| 393 | (shuffle sequence seed) | Creates a reordered sequence. |
| 394 | (sigma list ) | Calculates the sigma of a sequence. |
| 395 | (sign number option … ) | Returns the sign of a number as a number, sigil, or word. |
| 396 | (signal type term …) | Signals a failure. |
| 187 | (resignal tuple) | resignals a failure. |
| 397 | (significand number kind) | Calculates the modified significand as a number between 1 and 10, or zero. |
| 398 | (sine number geometry metrum) | Calculates the sine of a number. |
| 399 | (so expression … ) | Creates a task level scope. |
| 400 | (socket option … ) | Creates a TCP socket. |
| 401 | (some symbol … binding sequence expression … test) | True if the test is true for any element in the sequence. |
| 402 | (sort sequence ordering option … ) | Creates a sorted sequence. |
| 403 | (split sequence delimiter) | Creates a list of subsequences divided at a delimiter. |
| 404 | (starts-p interval1 interval2 tolerance) | True if two intervals start together. |
| 405 | (statistics numbers ) | Finds the mean, median, sigma, and count of a list of numbers. |
| 406 | (step symbol from i limit j by k expression … ) | Loops a symbol over a numeric range to evaluate expressions. |
| 407 | (stream streamable ) | Creates a stream. |
| 408 | (string value … ) | Converts a value to a string. |
| 409 | (structure name inclusion … definition … ) | Creates a structure. |
| 410 | (structures) | Creates a list of all structures. |
| 411 | (sub sequence entry … ) | Replaces a subsequence within a sequence. |
| 412 | (subset-p subset superset ) | True if all elements in a subset are in a superset. |
| 413 | (substitute sequence entry … ) | Copies a sequence and replaces subsequences. |
| 414 | (subsumes-p superset subset …) | True if all elements in each subset are in the superset. |
| 485 | (such symbol that premises option) | Returns a list of thoughts. |
| 415 | (sum value …) | Calculates the arithmetic sum. |
| 416 | (summation symbol … binding sequence expression … ) | Adds an expression over a set of values. |
| 417 | (supply arguments function environment) | Applies a function to an argument list. |
| 418 | (suppose facts action goals by strategies via operators limit quantity gate condition within timeframe before timepoint options options) | Performs hypothetico-deductive reasoning. |
| 419 | (survey format relation slot) | Creates a list of referents or referent-count pairs. |
| 420 | (swap sequence substitution …) | Modifies a sequence by interchanging values. |
| 421 | (symbol name ) | Creates a symbol. |
| 422 | (symbols environment ancestors ) | Lists the symbols in an environment. |
| 423 | (take readable count) | Creates an expression from a readable sequence. |
| 424 | (takeable readable desired) | Calculates the number of expressions that can be read. |
| 425 | (tally pattern ) | Returns the number of matches in the knowledge base. |
| 426 | (tangent number geometry metrum) | Calculates the tangent. |
| 427 | (tarry tasks expression … ) | Allows tasks to complete on their own. |
| 428 | (task scope expression … ) | Creates a list of tasks for deferred evaluation. |
| 429 | (tasks) | Creates a list of all tasks. |
| 430 | (taxon value) | Returns the datatype of a value. |
| 431 | (taxon-p value taxon) | True if the value is of the specific taxonomic type. |
| 432 | (taxonomy value) | Returns a list of datatypes for a value. |
| 433 | (tell who message timeout) | Sends a message to a recipient. |
| 434 | (there url ) | True if a file, folder, or url exists. |
| 435 | (this series) | The current element of a series. |
| 436 | (thought relation id ) | Finds an extant thought. |
| 437 | (thunk expression … ) | Creates a thunk in a module. |
| 438 | (thunks module) | Returns a list of thunks defined in a module. |
| 439 | (tick nanoseconds) | Creates a tick or returns nanoseconds since year zero. |
| 440 | (tie assignment ... ) | Assigns symbols to values in parallel. |
| 441 | (time unit operation time … ) | Performs time operations. |
| 442 | (top sequence count) | Creates a subsequence of the first elements. |
| 443 | (transfer source destination option … ) | Transfers a value from one sequence to another. |
| 444 | (traverse symbol binding sequence limit dimensions expression … ) | Loops through the coordinates of a sequence. |
| 445 | (trim sequence option … ) | Creates a sequence without front and rear delimiters. |
| 446 | (truncate number) | Rounds a number towards zero. |
| 447 | (try expression … learn symbol recovery … finally cleanup … ) | Evaluates expressions and recovers from signals. |
| 448 | (tuple value … ) | Creates a tuple. |
| 449 | (uid) | Creates a unique identifier. |
| 450 | (unbound function) | Creates a list of free symbols for a function. |
| 451 | (unbound-p symbol) | True if a symbol is unbound. |
| 452 | (unicode string) | The Unicode of a string’s first position. |
| 453 | (union sequence sequence … ) | Concatenates sequences removing duplicates. |
| 454 | (union sequence sequence … ) | Concatenates sequences removing duplicates. |
| 455 | (unique prefix) | Creates a unique literal based on a prefix. |
| 456 | (unless condition false-case true-case ) | Branched conditional execution. |
| 457 | (unlike sequence pattern) | True if a pattern does not match a sequence. |
| 458 | (unqualified function) | The function literal without the module prefix. |
| 459 | (unseal prototype) | Permits new records for a protoytpe. |
| 460 | (unsigned value ) | Converts a value to an unsigned number. |
| 461 | (until condition expression … ) | Loops expressions until a condition is true. |
| 462 | (unwrap module) | Permits modifications to a module. |
| 463 | (uppercase string) | Converts a string to uppercase. |
| 464 | (uppercase-p value) | True if a string's first position is upper case. |
| 465 | (url option … ) | Creates a URL resource. |
| 466 | (use knowledge expression …) | Evaluates expressions in a knowledge base scope. |
| 467 | (values assortment) | Creates a list of values for an assortment. |
| 468 | (vector atom … ) | Creates a vector of atoms. |
| 469 | (version) | Provides version information. |
| 470 | (void-p sequence) | True if a container has zero elements. |
| 471 | (wait tasks timeout ) | Waits for tasks to end. |
| 472 | (which pattern options ...) | Creates a list of thoughts for a pattern. |
| 473 | (while condition expression … ) | Loops expressions while a condition is true. |
| 474 | (whitespace-p value) | True if the first position of a string is whitespace. |
| 475 | (with premises option … action expression ) | Matches patterns against the knowledge base. |
| 476 | (within sequence position ) | True if a position is inside a sequence. |
| 477 | (wrap module) | Prohibits modifications to a module. |
| 478 | (write writeable value … ) | Writes values to a writeable resource. |
| 479 | (xnor truth truth) | Logical equivalance. |
| 480 | (xor truth truth) | Logical exclusive disjunction. |
| 481 | (yield value) | Returns a result from a series generator. |
| 482 | (zap container place … ) | Updates associations and sequences with nil values. |
| 483 | (zero-p number) | True if a number is zero. |
	
Table . Function Quick Reference
'''
# Bibliography

1\. Chambers, C. 1992  
The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages

2\. Forgy, Charles 1981  
OPS5 User’s Manual, Technical Report CMU-CS-81-135 (Carnegie Mellon University)

3\. Krishnamurthi, Sriram 2017  
Programming Languages: Application and Interpretation, Second Edition

4\. Linker, Sheldon O. 2005  
A knowledge base and question answering system based on loglan and english

5\. Linker, Sheldon O., Miller, M. S. P. 2014  
Association for the Advancement of Artificial Intelligence  
Spring Symposium Series 2014 (AAAI SSS 14)  
Implementing Selves with Safe Motivational Systems and Self-Improvement Invited Talk “Premise: A Language for Cognitive Systems”

6\. Miller, Michael S. P. 2013  
The Construction of Reality in a Cognitive System

7\. Miller, Michael S. P. 2018  
Building Minds with Patterns, ISBN 978-0-692-54140-1

8\. Queinnec, Christian 1994  
Lisp in Small Pieces, Cambridge University Press, ISBN 0-521-54566-8

9\. Steele Jr , Guy L. 1981  
Common LISP: The Language, 2nd Ed., Digital Press, ISBN 978-1-55558-041-4.

# Index

<-- before tie 37

\--> after tie 38

alias 34

anonym 56

Anonymous Functions 56

assert 67

assign 37

assume 37

async 72

atom 27

Auto-named Functions 56

binary 28

break 67

call 51

case 62

co 72

collection 44

complex 30

Complex numbers 30

configuration 45

constant 34

continuation 47

continue 67

data 47, 49

data types 25

date 32

decimal 29

Declarative Programming 24

do 64

Dynamic Scope 36

endoym 56

ensure 70

enumeration 45

environment 45

ephemerons 45

escape 70

exit 68

exonym 51

expression 57

fail 68

file 48

float 30

for 64

Functional Programming 23

Global Scope 35

go 71

hexadecimal 29

hexatridecimal 29

identifier 34

identity 42

if 62

imaginary 30

Imaginary numbers 30

Imperative Programming 22

instance 59

integer 28

interval 32

is 27

keywords 50

let 38

Lexical Scope 35

list 57

literal 40

long 29

long number 29

loop 65

method 43

Module Scope 35

modules 50

moment 32

nothing 27

number 28

octal 28

parameters 52

pattern 60

presume 39

prototype 42

radix 28

rational 29

Read Evaluate Print Loop 22

real 30

Real numbers 30

relatum 40

repeat 65

resource 44

Restricted Scope 36

resume 69

return 69

scatter 73

lexicon 46

seconds 32, 33

sequence 51

set 39

step 65

string 58

structures 40

symbol 34

Symbol Scoping 35

task 48

Task Scope 36

thing 27

thing-p 27

thought 46

tick 31, 33

tie 39

time 32

try 63

Tuples 59

unsigned 30

until 66

User Defined Functions 51

User Defined Macros 57

variant 27

vectors 58

when 63

while 66

![https://blu179.mail.live.com/ol/clear.gif]